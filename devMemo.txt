* 2023년 6월 23일 금요일

오늘 부트캠프 수료식이 있었다. 할 일 목록을 교육 기관에 의탁했던 4개월이 지나간 것이다. 이제 다시 혼자가 됐다.

혼자인 게 버거워 부트캠프에 지원했었다. 혼자선 모르겠는 게 너무 많았다. 
이걸 잘하려면 뭘 해야 하는지, 그 과정에서 어디까진 필수고 어디서부턴 굳이인지,
지금 이것저것 해보고 있긴 한데 이게 맞는 길인 건지, 아니라면 어떤 식으로 해나가야 하는지, 등등.
이거야 몹시 혼란했다. 망망대해에서 이런 저런 고민을 하고 있다 보면 쉽게 아득해져버렸다.

교육이 시작됐다. 업체발 할 일 목록의 은총이 내렸다. 처음엔 가랑비였다가 나중엔 장대비로 변했다. 어푸어푸.

일상은 단순해졌다. 하루하루 은총들을 무사히 치워내는 것만이 유일한 목표가 됐다.
머리가 가벼워졌다. 일상을 따로 계획할 필요가 없어진 덕이었다.
나는 흡사 패키지 여행 상품을 구매한 관광객의 마음으로 인솔자가 흔드는 깃발을 따라 발걸음을 옮겨대면 그만이었다.

하지만 그래서 뭐가 꾸역꾸역 술술 풀려갔다는 건 아니고, 이전과는 다른 결로 굉장히 버거워졌다.

부트캠프에 지원할 당시엔 이게 간절했다. 근데 어려웠다. 
뭐 당연하다면 당연했다. 이런 거 배워본 적도 없고. 난 그냥 일개 철학맨이었으니.. 그다음엔 뭐 방송 작가였고..
하루하루 나의 멍청함을 실감했다. 점점 더 멍청이가 되어가는 기분이었다. 괴로웠다.

후반부로 갈수록 간절했던 것이 빌어먹을 것이 됐다. 이 빌어먹을 거 얼른 끝나버렸으면 좋겠단 생각을 자주 했다. 이거야 염치도 없었다.

교육 후반에는 했어야 할 일들을 그냥 넘겨버리는 경우가 많아졌다. 의지박약이기도 했고 뭐 못 따라가기도 했고. 
이제부터 그것들이 부메랑처럼 돌아올 것이다. 그런 식으로 넘겨버린 것들이 보통 그렇듯이.

두 번의 프로젝트 때는 그래도 좀 재밌었다. 냅다 동영상 강의만 볼 때보다 훨씬 나았다.

이윽고 교육 기간이 끝났다. 시원한 기분은 하루가 채 지속되지 못했다.
이제부터 펼쳐질 하루하루를 뭘로 채워나가야 할까. 그 문제에 대한 결정은 온전히 내 몫이 됐다.

나는 다시 혼란해졌다. 고민이 많아졌다. 어쩌면 아무것도 몰랐던 때보다 더 그랬다.

2차 프로젝트 발표회를 마친 지난 주 토요일부터 수료식이 열린 오늘까지, 이런저런 생각을 했다.
개발맨이 되어내기 위해 갖춰야 할 것들을 좀 명확히 해보는 시간이었다.

아무튼 기록을 해야겠는데 마음에 드는 블로그가 없다. 왜 이렇게 안 이쁠까. 첫 번째 할 일이다.

* 건설 계획
: 원래는 하나의 파일이 하나의 게시물을 만드는 아주 정적인 페이지를 만들려고 했다. 데이터베이스가 거의 사용되지 않는. 방명록 정도에나 사용되는. 게시물 내용 수정 같은 것도 브라우저가 아닌 코드 편집기에서 문서 차체를 수정해 최신화하는 식으로. 

왜냐면 문서에는 html 태그도 들어가고 js도 들어가고 할 텐데 그런 내용 자체를 데이터베이스에 저장할 수가 없다고 생각해서.. 그동안의 프로젝트에서도 아이디, 비밀번호 등등, 그러니까 문자열 같은 것만 db에 저장했었다. 데이터가 들어갈 곳에 구멍을 뚫어놓고 사용자의 행동에 맞춰 데이터를 바꿔 꽂아넣는 방식이었다. 그러다 보니 온갖 태그들과 뭐 그런 것들을 담은 코드 뭉치는 db에 저장할 수 없다고 생각했던 것이다.

근데 그러면 굳이 react를 사용할 필요가 없다.

그리고 내 생각이 맞다면 네이버 블로그 같은 건 대체 구현될 수가 있는 건가 싶었다. 하나의 게시물이 생성될 때마다 html, css, js 파일을 만들어지고 그걸 저장해놨다가 요청하면 랜더링한다고..?

뭔가 방법이 있을 거다.

- 구성
: 헤더 + 페이지별 내용 + 푸터. 3단 구성.
	- 헤더 
		- 전역
	- 푸터
		- 전역
	- 페이지별 내용
		- 홈
			- 인삿말
			- 개별 게시물의 제목 리스트
			: 클릭하면 개별 게시글 내용 렌더.
		- 게시물 내용
			- 구성
			: 제목 + 생성일 + 수정일 + 본문 + 관련 게시물 링크
				- html 태그가 포함된 데이터(<p>안녕</p> 같은)는 데이터베이스에 저장해놓고 필요할 때 불러오는 식으로.
  
그냥 깔끔하게 글 제목이 나와 있고 클릭하면 해당하는 컨텐츠가 나왔으면 좋겠다.

* 어떤 스타일링 시스템을 사용할지
- 일단 css는 그럭저럭 생각대로 구현해낼 수 있는 정도.
- 문제는 일관되게 사용할 css 구현 체계를 아직 정립해내지 못했다는 점.
	- 일관된 className 작명이나.. 어떤 상황에서 container를 선언할지.. wrapper와는 어떻게 구별할지 등등.. 
	- 이런 식으로 해보자, 하고 하다 보면 특정한 대응 방식을 적용하기가 애매한 상황을 맞딱뜨리게 된다. 그럴 때면 기존 방식이 별로인 것 같고.. 그 점을 보완해서 다른 방식으로 작명을 하자니 앞선 작업 요소들을 다 바꾸느라 시간이 소요되고.. 아니 다른 프로그래머들은 그냥 쉽게 슉슉 지어나가는 것 같은데 나는 이거 하나 정하기가 왜 이리 어렵나.
	- 상/하위 관계를 나타내려고 상위 요소를 하위 요소의 클래스명에 포함시켜대다 보면 이거야 클래스명이 굉장히 길어져버린다. 그런 클래스명은 요소의 문맥을 반영되어 있어 찬찬히 살펴보면 이해하기 쉽다는 장점이 있지만, 애초에 읽기부터가 싫어져버린다는 게 단점이다.
	- 뭔가를 결정해야 하는 상황에 맞딱뜨릴 때마다 고민을 해야 하다 보니 흐름도 끊기고 시간도 가버린다. 어떤 고민이든 고민이 필요한 상황은 참 귀찮다. 그래서 인간은 당위를 만들어낸 듯하다. 당연한 것. 당연히 어떻게 해야 하는 것. 이게 맞는지 고민할 필요성을 지워버리는것. 예의나 규칙이나 법이나 인권 등. 나는 인간의 역사가 어떤 방향성을 띄게 되어 있는지 정확히는 모르겠지만, 개인적으로는 좀 더 편해지고 싶다, 라는 마음이 큰 영향을 미친다고 생각하고 있다. 나무를 해오고 적당히 패고 아궁이에 넣고 불을 지피고 음식을 데우고 중간중간 오버쿡돼버리진 않았는지 확인하고, 그런 게 영 귀찮아서 전자렌지가 탄생하는 식인 것이다. 예절이나 규칙 법이나 인권 등도 그렇다. 고민은 귀찮고 불편하다. 당연한 것이 정해져 있다면 고민의 필요성은 삭제된다. 편해지는 것이다. 당위는 인간 중 누군가에 의해 만들어지고 배포된다. 어떤 필요성과 그럴 듯한 이유들을 덧붙여져서. 인류 공동 창작인 경우도 있으려나. 특정 집단의 이익을 위해 만들어진 당위도 있을 것이다. 그걸 전면에 내세우거나 하지는 않겠지만. 아니라면 로비스트의 존재가 말이 안 된다. 인간의 필요에 의해 만들어진 당위들. 가만히 생각해보면 무서운 일이다. 대학교 시험에서 이런 문제가 나왔었다. 생명은 소중한가. 소중하다면 왜 소중한가. 아니라면 왜 아닌가. 인간은 평등한가? 인간은 평등해야 하는가?   
- sass, styled-component 중에 하나로 프로젝트를 해보려고 하는데 뭘 선택할지 고민이다. 어떤 도구가 시시때때로 만나는 귀찮은 고민들을 좀 덜어줄 수 있으려나. 역시 써봐야 알겠지. 

(내가 이해하기로는..)

1. sass
: (아마도) 기존 css에 프로그래밍 요소를 더한 스타일링 시스템 라이브러리. 즉, css 확장판.
  - sass 문법으로 스타일링 문서를 작성하면 css로 컴파일링되어 적용됨.
  - css 문법 그대로 사용.
  - 변수 사용 등 각종 프로그래밍적 편의 기능을 제공.
  - 중괄호 문법으로 상/하위 요소 관계를 꺽쇠보다 직관적으로 나타낼 수 있음.
  - 중괄호 문법으로 유효 범위를 생성할 수 있음. 스타일링할 요소의 타겟팅에 편리.
    - 상위 요소의 클래스명을 전체 문맥을 반영할 수 있게 신경 써서 지어주면 그 하위 요소 클래스명 네이밍은 훨씬 간결하게 해줄 수 있을 것 같음. 문맥을 반영할 필요가 없으니까.
			- 예) 
			.home-contentList-container {...}
			.home-contentList-contentList {...}
			.home-contentList-contentList-button {...}
			->
			.home-contentList_container {
        ...
        .contentList {
          ...
          .button {
            ...
          }
        }
			}
    -> 이걸로 클래스명 길어지는 문제는 어느 정도 해결할 수 있을 듯!
  - css 전처리기답게 html이 로드될 때 함께 로드됨. 그로 인한 성능상 이점은 캐싱이 되고.. 음.. 또..
    - 성능 관련한 부분은 차차 알아가보자.. 프로그래머들 엄청 깐깐하던데 널리 쓰이고 있는 시스템이라면 어련히 잘 되어 있겠지..? 무엇보다 아직 내가 성능 신경 쓸 수준이 아님.. 일단 구현부터 잘해내보자. 

2. styled-component
: (아마도) 일단 스타일링만 된 컴포넌트를 생성해내는 방식의 컴포넌트 스타일링 시스템 라이브러리.
  - 이름처럼 스타일링된 html 커스텀 태그(컴포넌트)를 생성.
  - 스타일링이 해당 컴포넌트에만 적용됨. 
    - styled-component 문법으로 생성한 컴포넌트에 고유한 해쉬값으로 구성된 클래스명을 장착해줌. 그 클래스명은 컴포넌트와 해당 컴포넌트에 적용될 스타일을 링크해줌. 자동 생성되는 클래스명에 중복이 없기 때문에 스타일링은 해당 컴포넌트에만 유효하게 됨. 즉, 클래스명 중복 이슈를 신경 쓸 필요가 없게 되는 것. 
    -> 이걸로도 클래스명 길어지는 문제는 어느 정도 해결할 수 있을 듯! 
  - 스타일링과 컴포넌트 생성/사용을 한 문서에서 처리할 수 있어 편리함. 스타일링 파일을 왔다갔다 하지 않아도 됨.
  - 한 문서에 있는 데다 js를 사용하기 때문에 scss보다 스타일링을 프로그래밍적으로 다룰 수 있음.
    - props를 전달받아 스타일링 내용 자체를 변경할 수 있는 등.
      - scss 스타일링 시스템에선 스타일링 내용 자체를 변경할 순 없음. 해당 className에 링크되어 있는 스타일링 문서가 정적이니까. 스타일링을 동적으로 변경하려면 특정 상황에서 요소에 다른 className이 적용될 수 있게 js로 처리해줘야 함. 반면 스타일드컴포넌트 방식에선 props를 이용해 스타일링 내용 자체를 동적으로 변경할 수 있음.
  - js 기반이라는 점에서 장점과 단점이 있을 듯. 아직 세세하게 알진 못함.
    - 런타임에 로드.
      - 음.. 뭔가 있겠지..
    - 이것도 차차 알아가도록 하자..

결론
: 일단 sass로 작업하고 후에 styled-component로 변환해보기로 했다.
- css 기본기를 탄탄하게 다지는 게 우선이라는 생각.
- 스타일링 정석부터 마스터하고 좀 더 특화된 방식을 사용하는 게 좋겠다 싶음. styled-component는 좀 더 프로그래밍적인 기능도 많으니까. 스타일링 상속? 복사?라든가. 뭔가 특화된 방식은 아무래도 기본을 제대로 습득하고 익히는 게 맞는 것 같음.

* 2023년 6월 26일 월요일

<grid>
- fill, fit
  - fill
  : 컨테이너에 한 줄에 빈 너비가 있으면 요소의 개수를 늘려서 빈 너비를 채운다.
  
  - fit
  : 컨테이너 한 줄에 빈 너비가 있으면 기존에 있던 요소의 너비를 늘려서 빈 너비를 채운다.

<이래서 스타일드 컴포넌트 쓰는구나.>
: 스타일링/스크립트 문서 왔다갔다 안 하고 한 문서에서 싹 다 처리할 수 있으면 좋겠단 소망이 싹트네.
: 스타일드 컴포넌트로 스타일링하자.

<스타일드 컴포넌트>
: enhance CSS for styling React component systems.
- 장점
  - 컴포넌트를 추적. 랜더되어야 할 것과 아닌 것 구분. 랜더에 필요한 만큼의 코드만 로드함.
    - 리소스 부담이 줄어들겠죵???
  - 이름 짓기 부담 줄임. 왜? 유일한 클래스네임을 생성하기 때문. 컴포넌트에 1:1로 대응됨.
  - 유지보수에 탁월함. 특정한 컴포넌트에 영향을 주는 스타일을 찾아 여러 파일 간을 이동하지 않아도 됨. 스타일드 컴포넌트와 함께라면 부처님 손바닥 안임.
  
- 참고
  - https://www.zigae.com/styled-components-abstract/
  : 스타일드 컴포넌트의 동작 원리에 대한 글
  
- 사건 사고
  1. 스타일드 컴포넌트 라이브러리 설치가 안 됨.
  : npm install을 아무리 해봐도 안 되는 것임!!!
  - node도 재설치해보고 했는데 안 됨.
  - yarn 설치해서 해결.
  - 근데 yarn으로 설치한 후에 npm으로 다시 설치하니까 또 잘 됨..
  - yarn 제거.

<시멘틱 태그>
: 시멘틱 태그를 잘 써보자. 나는 블로그에 글을 쓰고 싶고 그 형식이 좀 올바르면 좋겠으니까.

- 종류
: 시멘틱 태그는 엄청 많음.
: section, main, article.. 굉장히 헷갈린다. 
  - section
  : 구획.
  : 애매하면 section.
    - 홈 화면에서 각각의 게시물 제목 리스트는 section일까 main일까. 페이지의 중심 컨텐츠니까 main으로 잡았었는데 설명을 읽다 보니 main은 페이지당 하나만 들어가는 게 좋다고 한다. 그래서 section으로 바꿈.
    - 근데 또 main이 맞는 것 같기도 하고.. 이런 식이다. 태그 이름보다는 일관성이 중요하다는데 내 기준이 명확히 서 있지 않아서 항상 갈등하게 된다. 상황상 쓰임과 의미상 쓰임이 일치하지 않으면 골치가 아프다. 이것도 맞는 것 같고 저것도 맞는 것 같고. 골치치.

  - main
  : 가장 주가 되는 요소.
  : section 대신 써도 상관 없을 듯.
    - 페이지당 하나의 main만 존재하는 게 바람직하다고 함.

  - time
  : 시간.

<설계하다 보니까 구현하고 싶은 게 엄청 많은데..>
: 일단 필수 기능만 구현하자. 게시글을 html 태그를 이용해 작성하고 수정하는 기능을 구현하는 게 우선.
- 필수 기능
  1. @전역: 헤더, 푸터
  2. @홈: 게시물 제목 리스트
  3. @게시물 상세: 내용 렌더링 기능, 내용 수정 기능

<설계 변경>
1. 정적 -> 동적
- 처음엔 정적인 블로그를 만들려는 생각이었음. 이전에 html css js로 만들었던 블로그처럼 링크를 클릭하면 해당 게시물을 이루는 파일을 로드해주는.  
  - 링크를 클릭하면 게시글 파일을 로드시켜 보여주는.
  - 서버에서 데이터를 받아올 일이 없음.
- 근데.. 그러면 리액트로 만들 필요가 없다.. 는 생각이 듦.
- 나는 게시물 내용을 html 태그를 사용해서 구성하고 싶음.
- 게시물 내용을 구성하는 코드를 서버에 저장할 수가 있나..? 안 해봐서 모르는 상태임.
- 문자열로 저장할 순 있을 것 같음. 근데 그걸 가져와서 렌더링을 할 수 있을지.. 그리고 몇 가지 방법을 찾았음.
  1. dangerouslySetInnerHTML
    : js의 innerHTML 같은 기능. dom을 직접 조작해 서버에서 받아온 html 내용을 삽입한다.
    - 문제는 react에서 권장되지 않는 방법이라는 거. react는 프로그래머가 가상 dom을 조작하고 그렇게 생성됨 돔을 가지고 react가 진짜 dom과 비교해 dom을 업데이트함. 즉, js처럼 프로그래머가 직접 dom을 조작하면 안 된다는 거.
    - 근데 dangerouslySetInnerHTML는 dom을 직접 조작함.
    - 사용 보류. 다른 방법 먼저 찾아보자.
  
  2. 받아온 html 내용을 컴포넌트에서 그대로 렌더링.
  : 실패. 어떻게 해도 html 내용 자체(태그까지 포함)가 평범한 string처럼 렌더링됨.
    - 리액트가 XSS(Cross-site scripting) 공격을 막기 위해  마련한 방법이라고 함.
      - cross-site scripting 공격
      : 사용자가 악의적으로 입력한 코드가 로드되어 정보를 탈취하거나,, 아무튼 나쁜 일을 일으키는 식으로 공격하는 것.
        - 예를 들면 <img src="..." /> 이런 태그가 웹을 통해 악성 코드를 호출해낼 수 있음. img 태그에는 get 요청 기능이 있으니까.
    - 리액트는 이 공격을 방어하기 위해 태그가 포함된 string 데이터를 문자열 그대로 렌더링함. 그러면 문자열일 뿐인 태그가 작동하지 못하고 XSS 공격도 불가능해질 테니까.
    
  3. 받아온 html 내용을 바로 렌더링하지 않고 태그에 심어서 랜더링하면 어떨까.
  : document.create('div')로 요소를 생성 후 div.innerHTML('서버에서 받아온 데이터')로 html 내용을 탑재한 후에 해당 요소를 컴포넌트에 넘겨 렌더링 하는 것.
    - 소용없다. 역시 문자열로 바뀌어 렌더링됨.
    
- 결론적으로 dangerouslySetInnerHTML 속성을 사용해 게시물 내용 렌더링을 진행하기로 했음.
  - 다른 방법이 없음.. 아니 없는 것 같아 보임..
  - 렌더하는 데이터가 안전한 소스이기만 하면 되지 뭐. 어차피 내가 적은 것만 렌더링할 건데.
  - 사용자의 입력을 받는 곳(댓글, 방명록 등)에는 dangerouslySetInnerHTML 안 써야겠음. 그건 그냥 문자열로.
  
2. 스레드 형태로 만들면 어떨까.
: 게시물 주제에 대해 이전보다 더 발전된 생각이라든가 문제 상황에 대한 해결 아이디어가 시간이 지남에 따라 바뀌는 경우 등, 그런 것들을 순차적으로 기록해두고 한 번에 꺼내볼 수 있었으면 했다.
- 대부분의 블로그, 그러니까 게시판 서비스는 하나의 게시물이 기본적으로 다른 게시물과 독립되어 있음. 단편 소설집에 담긴 각각의 에피소드들처럼.
- 프로그래밍이라는 건 (아마도) 뭔가를 구현하는 데 따르는 문제들을 해결해내는 과정임. 문제 해결을 위한 도구(언어, 라이브러리 등), 해결의 아이디어를 떠올려내는 기반 지식의 정도에 따라 문제 해결 방향이 바뀜. 그리고 그것들은ㅡ가용 도구와 기반 지식ㅡ 시간에 따라 업데이트 됨. 즉, 시간에 따라 문제 해결 방식이 바뀔 수 있음.
- 이런 프로그래밍 공부의 특징엔 레딧, 트위터, 스택오버플로우처럼 스레드 형식의 게시판 구조가 더 적합하지 않을까, 라는 생각이 들었음. 다른 사용자들을 참여시키는 게 아니라 그냥 스레드의 형식만 가져오는 것. 작성은 나 혼자.
- 독립적인 게시물 형식도 이를 구현할 수 있는 방법이 있긴 하지만(같은 주제로 발행된 이전 게시물의 링크를 걸어놓는다거나, 관련 게시물을 토글 버튼 안에 접어놓는다거나) 뭐 그냥 그런 생각이 들었음.
  - 아니면 같은 주제의 게시물 내용을 시간에 따라 계속 수정하는 것도 방법. a few day later.. 이런 걸 구분 요소를 만들어 그때그때 삽입해주기. 게시물들의 기본 정렬 방식은 최근 수정일순으로 하고.
- 그러나! 구현 난이도가 더 높을 것 같음. 지금은 빨리 만들어서 기록에 사용하는 게 중요하니까.. 음..

- 결론) 일단 일반적인 블로그를 만든다. 스레드 형식은 이어질 혁명적 변화 목록에 넣어두고 나중에 여건이 되면 구현한다.

<페이지 분기>
: '/', '/posts/:id'
- react-router-dom의 기능 중 기본 기능 외에는 익숙하지 않음.
  - 일단 간단히 분기만 해놓고 개선할 때 찬찬히 문서를 읽어보자.
  
<db에서 받아온 html 포함 데이터 중 일부 html 태그가 적용되지 않는 문제>
: 대부분의 태그(<div>, <p> 등)들은 잘 적용되어 렌더링되는데 일부 태그(<b> 등)들은 기능하지 않는다.
- 근데 scss 문서에 class 지정해 씹히는 태그의 스타일링을 적용해주면 또 먹힌다.
- 젠장! reset css의 font: inherit; 코드가 <b> 태그의 font-weight: bold; 기능을 막고 있는 거였음!

* 2023년 7월 6일

<data json에서 >

 {
      "id": 1,
      "title": "전면개정판이기적유전자진화론의새로운패러다임1",
      "body": "   <div>안녕하세요. 블로그를 만들고 있습니다. 쉽지 않네요.</div>\n    <p>급하게 <b>집</b>을 파셨더라구요. 필리핀 가시게요?</p>\n    <p>형님, 병원 도착 전에 손쓸 틈이 없었습니다.</p>\n    <b>바이루</b>",
      "date": "2023년 1월 1일"
    },

<<></>가 없어도 되는구나>

<비상. 내용에 <>가 들어가면 그대로 태그로 로드가 됨>
-> 

앞에 있는 공백이 없어졌으면 좋겠는데...

우선 textarea 크기부터 고쳐보자.
- 기왕이면 자동으로.

texteara에 출력되는 내용은 어차피 태그 그대로 출력되니까 상관없음
문제는 html 렌더러에서 태그가 활성화되면 안 되는 부분을 처리하는 것.

하,, 라이브러리 쓸까..

1. textarea
  - 되는 것
    - db에서 html 태그로 작성된 내용 그대로 받아오기

  - 되어야 할 것
    - 

라이브러리는 ckeditor아니면 draft.js.
- ckEditor는 디자인이 마음에 듦.
- draft.js는 페이스북에서 만들었으니까 리액트 사용자가 사용하기 펴리할,, 지도 모른다.

그냥 라이브러리로 해결하기로 했음...

ckEditor로 대충 원하는 기능이 돌아가는 것까지는 확인했음! 

다른 라이브러리를 쓰기로 했다.

node_modules 디렉토리는 주로 프로젝트에 사용되는 외부 라이브러리 및 종속성을 포함하는 곳입니다. 

@로 시작하는 폴더는 일반적으로 스코프(scope)를 가진 패키지를 의미합니다. 이는 일반적으로 공개 범위(scope) 내에서 패키지를 그룹화하고 구분하기 위해 사용됩니다. 예를 들어, `@organization/package-name`와 같은 패키지는 특정 조직 또는 그룹에 속하는 패키지를 나타내며, 다른 패키지와의 충돌을 방지합니다.

일반적인 패키지는 스코프를 가지지 않으며, 패키지 이름만을 가지고 있습니다. 예를 들어, `package-name`과 같은 패키지는 스코프가 없는 패키지를 나타냅니다.

이러한 차이점은 패키지 이름의 유일성을 유지하고 충돌을 방지하기 위한 목적으로 사용됩니다. 스코프를 가진 패키지는 일반적으로 특정 조직, 프로젝트 또는 네임스페이스에 속하는 패키지를 관리할 때 유용합니다.

- 제어된, 제어되지 않은 컴포넌트
: 무슨 차이일까? 어떤 상황에서 뭘 써야 할까?

react-quill을 쓰기로 했음.
- 체득에 추가
- 지금 해결해야 할 건
  1. 편집기에서 작성한 대로 안 나오는 문제
    - 두 가지 해결 법
      1. 가존 자체 제작 viewer의 css를 만진다.
        - 리셋 css 끄면 되나!?
          - 안 됨. 줄 높이 같은 건 맞춰지는 듯.
        - 
      2. quill viewer를 쓴다.
  2. 편집기에 기능 추가.
    - 이건 간단하다. 이미 내장된 걸 가져오기만 하면 됨.

  3. 이미지 관련 기능 추가
    1. 이미지 업로드
    2. 이미지 리사이징
    3. 붙여넣기로 이미지 추가

css) selector[속성] {...}
: 해당 속성을 가지고 있는 요소들을 선택한다.
  - ex) ddd 속성을 가지고 있는 ul을 선택.
    1. <ul>...</ul>
    2. <ul ddd>...</ul>

    ul[ddd] {...} // 2번 요소만 선택됨.
  
  - 속성은 ddd라고만 적어주면 됨. true나 false를 줄 필요 없음.
    - 줄 수도 없음.

css) selector::before {...}
: 가상 선택자. 선택 요소의 앞을(왼쪽을) 선택한다.
: 선택한 요소의 앞에(왼쪽에) 어떤 컨텐츠를 넣고 그 컨텐츠의 스타일을 설정할 때 사용한다.
  - ex) li 앞에 체크 요소 넣기
    li::before { content: 'V'; color: green; } // li의 컨텐츠 앞에(왼쪽에) 'V' 요소가 추가됨.
  
  - 참고) 
    - 리스트 앞에 붙는 중간 점이나 숫자(1. 2.)는 ::maker 가상 선택자. 
      - li::marker {...} 이렇게 css를 설정해 기존의 marker를 다른 형태의 요소로 교체할 수 있음.

css) height: 100%;
: 부모 요소의 100%. 
: 콘텐츠의 100%가 아니다.
  - 부모 요소의 height가 명시적으로 지정되어 있지 않거나 동적으로 변경된다면 그에 맞춰 변함.
    - 전체 요소를 .wrapper로 감싸주고 높이를 100vh로 주면 바로 하위 요소의 height 100%는 100vh가 됨.
      - 이렇게 항상 화면을 꽉 채울 수 있음. .wrapper로 한 번 감싸주는 이유가 이건가?

css) selector:(가상 클래스)
: 요소의 특정 상태(나 위치)에 따라 스타일을 적용한다.
  - ex) 마우스를 오버하면 스타일을 변경.
    selector:hover {...}

css) selector::(가성 선택자)
: 요소의 특정 부분에 스타일을 적용하기 위해 추가적인 요소를 생성하거나 선택한다.
  - selector::before {content: '...';}는 요소의 앞에 다른 요소를 추가.
  - selector::after {content: '...';}는 요소의 뒤에 다른 요소를 추가.

quill css 변경
- dist 경로에 있는 css 파일을 변경했더니 변경 사항 반영이 안 됨.
- 근데 그걸 카피해서 Editor 폴더로 가져와 적용시켜준 뒤에 css를 변경하니 바로 적용이 됨.
- 왜? 빌드된 채로 있어서 그런가?

빌드
: 소스 코드와 소스 파일들을 실행 가능한 형태로 변환하는 과정.
: 1. 소스 코드 컴파일링 2. 의존성 관리 3. 번들링 4. 최적화 과정이 수행된다.
  - 과정
    1. 컴파일링
    : 인간이 작성한 소스 코드를 컴퓨터의 언어로 바꾼다.
      - 프랑스인에게 내 말을 이해시키는 방법은 두 가지가 있겠음. 
        - 1. 프랑스인에게 한국어를 가르치고 한국어를 원어로 읽게 함. 
        - 2. 한국어를 프랑스어로 컴파일해서 프랑스어로 읽게 함. 
        - 뭐가 더 효율적일까? 당연함. 2번임.
      - 컴퓨터에게도 마찬가지임.
        - 전교 1등에게 그 자식만의 암기법이 있듯이 컴퓨터에게는 컴퓨터만의 이해 방식이 있음.
        - 하지만 소스 코드라는 건 인간이 작성하기 때문에 인간의 언어 체계가 반영되어 있을 수밖에 없음.
        - 컴퓨터에게 인간의 언어 체계를 가르치고 인간적인 소스 코드 원문을 그대로 읽게 하는 건 비효율적임.
      - 컴퓨터에게는 컴퓨터만의 이해 방식이 있음. 컴퓨터에겐 그 방식으로 작성된 문서를 넘겨주는 게 훨씬 효율적.
      - 즉, 컴파일링은 개발자의 프로젝트(소스 코드들)를 컴퓨터의 모국어로 바꾸는 작업.
        - 소스 코드를 짜는 단계 이후엔 해당 코드는 컴퓨터만 이해할 수 있으면 됨. 컴퓨터가 작동시킬 거니까.
    
    2. 의존성 관리
    : 프로젝트에서 사용되는 외부 패키지를 가져온다.
      - 사용되는 소스 코드를 가져와 정리해놓는다는 거겠지..?
    
    3. 번들링
    : 프로젝트에서 사용되는 모든 파일을 하나로 묶는다.
      - 여러 개의 파일을 왔다갔다 하며 실행하는 것보단 하나로 묶어놓는 게 효율적이니까. 정리만 잘 해놓으면.
  
    4. 최적화
    : 번들링된 파일의 크기를 최소화하고 성능을 향상시키는 작업을 수행한다.
      - 이 단계에선 코드 압축, 이미지 최적화, 트리 쉐이킹 등을 수행함.
        - 불필요한 코드를 제거하는 등.
        - 각각의 방법들에 대해선 아직 잘 모름. gpt가 알려준 거 우선 써놓겠음.
        - gpt)
          변수와 함수 이름의 대체 및 코드 압축은 일반적으로 빌드 과정 중의 하나인 "코드 압축(Code Minification)" 단계에서 이루어집니다. 코드 압축은 빌드 도구에 의해 수행되며, 일반적으로 다음과 같은 단계로 진행됩니다:

          1. 공백, 주석, 들여쓰기 등의 제거: 코드 압축 단계에서는 불필요한 공백, 주석, 들여쓰기 등을 제거하여 파일 크기를 줄입니다. 이렇게 함으로써 다운로드 속도를 향상시키고 네트워크 요청 수를 줄입니다.

          2. 변수와 함수 이름 단순화: 코드 압축 도구는 변수와 함수 이름을 단순화하기 위해 다양한 기법을 사용합니다. 이는 변수와 함수 이름을 짧은 이름 또는 알파벳순으로 나열된 이름으로 대체하는 것을 의미합니다. 이 과정은 일반적으로 압축 알고리즘 또는 토크나이저(Tokenizing)를 사용하여 이루어집니다.

          3. 스코프 충돌 방지: 코드 압축 과정에서는 변수와 함수 이름의 스코프 충돌을 방지하기 위해 유효범위(scope)를 고려합니다. 압축 도구는 동일한 스코프 내에서 중복되는 이름이 충돌하지 않도록 유일한 이름으로 대체합니다.

          4. 소스 맵 생성: 소스 맵(Source Map)은 압축된 코드와 원본 코드 간의 매핑 정보를 제공합니다. 이 매핑 정보를 사용하면 디버깅 도구에서 압축된 코드를 원본 코드로 매핑하여 원본 코드에서 디버깅을 수행할 수 있습니다. 소스 맵은 일반적으로 압축된 코드와 함께 생성되어 웹 페이지에서 사용됩니다.

          요약하면, 변수와 함수 이름의 단순화 및 코드 압축은 빌드 과정 중 코드 압축 단계에서 이루어지며, 공백과 주석 제거, 단순한 이름으로 대체, 스코프 충돌 방지 등의 기법을 사용하여 최적화된 코드를 생성합니다. 이를 통해 파일 크기를 줄이고 성능을 향상시킬 수 있습니다.

  - 즉, 프로젝트는 빌드를 통해 최적화되고 배포 가능한 상태가 됨.
  - 이런 빌드는 Webpack 등의 자동화된 빌드 도구를 사용해 처리함.
    - 도구의 설정 파일을 통해 빌드 과정을 제어할 수 있음.
  - 모든 과정이 끝나면 프로젝트를 빌드한 결과물을 서버에 올림. 이를 배포라고 함.
    - 배포를 위한 파일들을 서버에 업로드.
    - 웹 페이지에 접근할 수 있도록 웹 서버를 설정함.

뷰어
- quill bubble 테마를 사용하고.. css 설정을 그거랑 대응되게 맞춰야 할 듯.
- 이 작업 하면서 뷰어의 css를 어떻게 설정해야 마음에 드는지 한번 보자.


  
      






      
