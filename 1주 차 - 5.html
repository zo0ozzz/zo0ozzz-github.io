<!DOCTYPE html>
<html lang="ko" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>zo0ozzz</title>
    <link rel="stylesheet" href="css/css.css">
  </head>
  <body>
    <div class = "container1">
      <div></div>
      <div class = "container2">
        <!-- 블로그 이름 -->
        <div class="head_blogName">
          <a href = "index.html" class = "h_blogName"></a>
          </div>
        <div></div>
        <!-- 날짜 -->
        <div class="section_head_date">
          <div class="s_h_date">
            2023년 3월 3일 금요일
          </div>
          </div>
        <div></div>
        <div></div>
        <!-- 제목 -->
        <div class="section_head_subject">
          <h1 class="s_h_subject">
            1주 차 - 5
          </h1>
          </div>
        <div></div>
        <div></div>
        <!-- 본문 -->
        <div class="section_body">
          <pre class="pre_text">
1-1-5(230303)

git

&lt;커리큘럼&gt;

git이란?
- git은 무엇인가.
- git을 사용하는 이유

git 시작하기
- git 명령어.
- git 저장소 만들기.

git 가지치기
- 동일한 소스 코드를 공동으로 개발할 수 있게 해주는 기능.
- 마주칠 수 있는 문제들.

git 원격 저장소
- 로컬 저장소에 원격 저장소를 연결하는 방법.
- 로컬 저장소와 서버에 존재하는 저장소를 이용해 협업하는 방법.

&lt;학습 목표&gt;
- git을 사용하는 이유를 설명할 수 있다.
- git 환경을 구성할 수 있다.
- git을 사용하여 프로젝트를 효율적으로 관리할 수 있다.

git이란?

git을 사용하는 이유

- 효율적인 협업
: 동시에 한 가지 파일을 수정하는 경우 각자 수정한 버전을 자동으로 비교하여 통합해준다.

- 쉬운 버전 관리
: 각각의 버전을 계속해서 스냅샷 형태로 저장하여  버전 탐색, 버전 간 이동이 간편하다.
  - 최종. 최최종. 최최최종. 대가리 깨져도 최종. 피 질질 흘리며 최종. 이렇게 수동으로 최신화를 시켜줄 필요가 없음. git이 알아서 저장하고 요청 시 이전 버전을 내어줌.

git의 특징

1. 가지 치기와 병합
: branch 기능. 메인 코드에서 뻗어나온 가지, 라는 의미.
: 메인 코드를 기반으로 여러 연관 개발 작업이 각자의 브랜치 공간에서 진행된다. branch에서 진행되는 작업은 메인 코드에 병합 전까지 메인 코드에 대해 독립성을 갖는다. 즉, 메인 코드에 영향을 주지 않는다.
- 즉, 여러 가지들에서 개발, 테스트 등을 진행한 후 메인 코드에 반영하여 배포를 진행함.
- 이렇게 각각의 작업에 독립성이 유지되기 때문에 효율적인 협업이 가능해짐.

2. 가볍고 빠르다.
: 거의 모든 작업을 서버와의 통신 없이 로컬에서 진행할 수 있기 때문에.
  - svn은 모든 코드가 중앙 서버에, git은 각각의 로컬 사용자들에게 존재.
- svn은 중앙 시스템에 여러 개발자가 접속해 코드를 공유하는 방식. 즉, 항상 네트워크가 필요.
- git은 타인과 코드를 공유할 때만 중앙 서비스에 접속하면 됨으로 네트워크 속도와 관계 없이 매우 빠른 작업이 가능.

효율적인 분산 작업
: 개발자들은 개발에만 집중하고 통합 관리자는 개발된 코드를 병합하는 데만 집중할 수 있는 구조를 제공.
- git 사용자들은 메인 코드를 복사한 코드를 가지고 있기 때문에 각자의 브랜치에서 동시에 작업을 진행할 수 있음.
- 소스 코드를 병합하는 건 번거로운 일이지만, 깃을 사용하면 통합 관리자를 두어 그 역할만 전담하게 할 수 있음.

데이터 보장(프로젝트 무결성 보장)
: 의도하지 않은 요인에 의해 데이터, 소프트웨어, 시스템 등이 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장한다.
- 모든 파일은 체크썸이라는 검사 과정을 거침. 그 과정에서 파일에 16진수의 문자열이 부여됨.
- 이 문자열은 그 파일이 무엇인지, 내용이 무엇인지, 누가 작업했는지, 언제 작업했는지 등에 의해 정해짐.
- 두 파일에 부여된 문자열이 같다는건 두 파일이 서로 완벽하게 같다는 것.

준비 영역(staging area)
: 로컬 영역에서 작업된 코드가 원격 저장소에 저장되기 전 머무는 영역.
- 수정한 코드를 레파지토리에 반영하기 전 검토하는 단계.
- 반영할 파일을 git add &lt;name&gt; 명령어로 스테이징 에어리어에 보냄.
- 스테이징 에어리어에 머물러 있는 파일을 git commit 명령어로 커밋하면 작업물이 원격 저장소에 반영됨.

오픈 소스
: 소스 코드가 공개되어 있어 누구나 프로젝트의 발전에 기여할 수 있는 프로젝트.
- git은 전 세계의 수많은 프로그래머들에 의해 계속 발전되고 있음.

git 호스팅 서비스
: 원격 저장소를 제공하는 서비스.
- 깃허브, 빗버켓, 깃랩 등.

3. git 설치와 초기 설정

초기 설정

config
: configure. 구성하다. (컴퓨터 등의) 환경을 설정하다.
- 예)
  - git config --global user.name "zo0ozzz"
  : 사용자 이름
  - git config --global user.email "zo0ozzz@zo0ozzz.io"
  : 사용자 이메일
  - git config --global user.shoese "adidas superstar 270"
  : 사용자 신발
  - git config --list
  : 저장된 사용자 정보 출력
- --global
:
  - git 저장소가 시작되지 않은 상태에서는 유저 설정 시 반드시 --global을 입력해야 한다.
  - 오류 메세지
  : fatal: not in a git directory

4. git 저장소 생성

1. 기존 디렉토리(폴더) 사용
: 기존에 존재하던 폴더를 git 저장소로 지정한다.

- git init
: initialize. 초기화하다. 초기 내용을 설정하다.
: 해당 폴더를 git repository로 지정해주는 명령어.
  - project라는 폴더를 깃 저장소로 지정하려면 - git init ./teaparty/project 이런 식으로 디렉토리를 적어주거나, project 폴더에 접근해 -git init 명령어를 입력.
    - 저장소 지정이 성공하면 디렉토리에 .git 디렉토리가 생성됨.			- cd 디렉토리
      : 디렉토리에 접근
    - ls -al
    : 디렉토리의 파일을 출력해주는 명령어.

2장 git 시작하기

수강 목표
1. git 저장소에 작업 내용을 반영할 수 있다.
2. git 저장소의 세 가지 영역을 알 수 있다.
3. git 저장소의 현재 상태를 파악할 수 있다.

1. git 파일 생성

새로운 파일 생성
: 원격 깃 저장소에 파일을 커밋한다.

2. 저장소의 이해
: 파일이 머무는 세 가지 영역이 있다. 워킹 디렉토리, 스테이징 에어리어, 레파지토리.
  - 워킹 디렉토리
  : 로컬에서 작업이 이루어지는 영역.
  - 스테이징 에어리어.
  : 작업 완료된 파일이 머무는 영역.
  - 원격 레파지토리
  : 원격 저장소. 작업 완료된 파일의 최종 목적지.

3. git 저장소 반영
: 원격 깃 저장소에 파일을 커밋한다.
- 처음 파일이 워킹 디렉토리에 있을 때는 untracked 상태. 뭔가 수정이 이루어졌다면 modified 상태가 됨.
- git add &lt;파일 이름&gt; 명령어로 파일을 스테이징 에어리어로 보냄.
  - 추가할 파일이 많으면 git add .로 폴더 전체를 스테이징 에어리어로 보낼 수 있음.
- git commit 명령어로 파일을 원격 저장소로 보냄.
  - git commit -m "Initial commit"
  : -m 옵션을 입력하면 커밋 메세지를 남길 수 있음.
    - 생략할 수도 있지만 추후 수정 내용을 쉽게 짐작할 수 있도록 적절한 메세지를 넣어주는 걸 권장.
  - git commit --amend 명령어로 커밋 메세지를 수정할 수 있음.
- 스테이징 에어리어에서 커밋된 파일은 다시 언모디파이드 상태가 됨.
- 파일을 지우면 언트랙티드 상태.
  -&gt; ?? 그래?
- git log 명령어로 저장소 반영 내역을 확인할 수 있음.
: 모든 커밋 확인 가능.
  - log 옵션
    - git log -p(atch) -2
    : 상위 n개의 커밋만 보여주는 명령어.
    - git log --stat
    : 커밋 된 파일의 어떤 부분이 변경되었는지 보여주는 명령어.
    - git log --pretty=oneline
    : 각 커밋을 한 줄로 보기 좋게 보여준다.
    - git log --graph
    : 커밋의 연결 관계를 아스키 그래프로 출력한다.
      - 브랜치가 있을 경우 유용함.
    - git log -S &lt;name&gt;
    : 코드에서 변경된 내용 중 특정 텍스트가 포함되어 있는지 검사한다.

3. git 관리 상태 확인
: git status 명령어로 폴더의 어떤 파일이 변경되었는지 등 파일의 상태를 확인할 수 있다.

- git diff
: 커밋 된 파일의 변경된 사항을 비교한다.

- git reset
: 스테이징 에어리어에서 파일을 삭제.

3장. 깃을 사용한 버전 관리

수강 목표
1. git에서 브랜치를 만들 수 있음.
2. 여러 작업을 독립적으로 진행할 수 있음.
3. 브랜치의 내용을 병합할 수 있음.

1. git branch 명령어

git branch
: 메인 코드에서 뻗어나와 연관된 작업을 독립적으로 진행할 수 있게 한다.

git 브랜치의 종류
1. 메인 브랜치
: 배포할 수 있는 수준의 안정적인 브랜치.

2. 토픽 브랜치
: 기능 추가 버그 수정과 같은 단위 작업을 위한 브랜치
: 수시로 생겼다가 없어진다.

git branch 명령어

- git branch &lt;name&gt;
: 새로운 브랜치를 만드는 명령어.
  - 깃 레파지토리를 만들면 기본적으로 master 브랜치가 생성됨.
  - git branch &lt;name&gt; 명령어로 독립적인 작업을 위한 새로운 브랜치를 만듦.

- git branch
: 현재 존재하는 브랜치와 자신이 위치해 있는 브랜치를 보여준다.

- git checkout &lt;name&gt;
: 자신의 위치를 특정한 브랜치로 전환.
  - 헤드 포인터가 가리키는 브랜치가 현재 자신이 위치한 브랜치.
  - git log로 확인한 snapshot을 넘나들 때도 사용 가능함.
    - git checkout &lt;16진수 해쉬&gt;

git merge

병합 방식

1. fast-forward
: 빨리 감기. 시간의 흐름을 앞당기다.
: 마스터에서 갈라져나와 작업된 브랜치가 마스터의 내용을 모두 포함하고 있을 때의 병합 방식.

- 방식의 이해
  - 마스터 브랜치가 자신보다 미래에 찍힌 체크 포인트를 따라잡는다, 라고 이해하면 간단할 듯.
  - 마스터 브랜치의 cp(check point)를 cp1이라고 한다면, 마스터 브랜치에서 뻗어나와 작업된(수정된) 브랜치는 cp2를 형성함.
  - 만약 뻗어나와 수정된 브랜치의 내용이 마스터 브랜치를 온전히 포함하고 있다면, 즉 원본(마스터)을 손상시키지 않은 채 덧붙이기만 하는 방식으로 업데이트 됐다면, 이때 이 브랜치와 마스터 브랜치의 병합은 fast-forward 방식으로 진행된다.
  - cp1의 마스터 브랜치가 cp2의 수정된 내용을 받아들이는 형식으로 병합된다. 그러니까 마스터 브랜치가 자신의 미래(기존 자기 자신의 내용에 무언가 덧붙여진 모양의 브랜치)를 따라잡는다는 느낌으로.
  - 이때 master 브랜치와 다른 브랜치는 모두 같은 cp, 즉 cp2를 가리키게 된다.
  -뭔가 운명론적 방식의 병합이다. 나의 미래는 이미 정해져 있고 나는 그것을 실현해 나갈 뿐이다.. 그 과정에서 나는 변화하지만 무엇도 버릴 수 없다.. 오늘까지의 나를 적분하면 꼼짝없이 내일의 나일 테니까..

- 실현  과정
  - master에서 뻗어나온 브랜치에서 코드를 수정.
  - git checkout master 명령어로 내 위치를 master 브랜치로 전환.
  - git merge &lt;수정된 브랜치&gt; 명령어로 두 브랜치를 병합.
    - master 브랜치를 cp2로 이동.
  - master 브랜치가 갖고 있는 모든 내용이 다른 브랜치에 포함되어 있다면, 곧바로 두 브랜치가 병합된다.

2. fast-forward 방식 외의 병합 방식
: master 브랜치와 master 브랜치에서 뻗어나온 브랜치가 각각 동시에 수정됐을 때의 병합 방식.

- 방식의 이해
  - fast-forward 방식에선 master 브랜치는 수정되지 않고 master 브랜치에서 뻗어나온 브랜치만 수정됐음. master 브랜치가 온전히 유지되고 있었기 때문에 뻗어나온 브랜치가 master 브랜치의 내용을 온전히 담고 있을 수 있었음.
  - 하지만 마스터 브랜치와 뻗어나온 브랜치가 동시에 수정된다면 어느 각각의 브랜치는 다른 브랜치의 내용을 온전히 갖고 있지 않게 될 수 있음. 그렇다면 fast-forward 방식의 병합은 불가능해짐.
    - master 브랜치와 거기서 뻗어나온 A 브랜치가 있고 두 브랜치가 모두 수정됐으면 수정된 master 브랜치와 수정된 A 브랜치의 cp는 cp2와 cp3이 됨.
  - master 브랜치로 전환해 git merge A를 해주면 master에서 수정했던 내용이 A 브랜치의 수정 내용을 받아들여 두 브랜치가 병합되고 cp4가 생성됨.
  - 보통 병합이 끝난 토픽 브랜치는 기능 개발이나 작업이 끝나면 삭제해주는 게 일반적임.
    - git branch -d &lt;name&gt;으로 삭제.

3. 병합 과정에서의 충돌
: 병합 대상인 두 브랜치에서 같은 파일을 동시에 변경했을 때 충돌이 발생한다.
- 이전까지는 같은 파일을 변경하지는 않았기에 충돌이 없음. 작업 내용은 다르지만 동시에 같은 파일을 건드리진 않음. 즉, 각각 독립되어 있는 브랜치가 수정되었음.
- 이 경우 자동으로 병합되지 않고 사용자의 의사 결정으로 직접 충돌을 해결해줘야 함.
- git status 명령으로 어느 파일에서 충돌이 발생했는지 확인할 수 있음.
  - both modified: &lt;comment.js&gt; 메세지 확인.
- 어떤 내용으로 병합해야 할지 확정해달라, 는 의미.
- 충돌이 일어난 파일에 접근해 사건 발생 지점을 직접 수정함.
  - 시스템이 충돌 지점 확인을 위해 표시해놓은 기호를 삭제해야 함.
- 수정 완료 후 충돌이 발생한 파일에 git add, git commit 과정을 부여해 다시 git merge를 명령.
- 해결도 중요하지만 방지하는 게 더 중요함. master 브랜치의 변화를 지속적으로 가져와 충돌을 방지하는 게 도움이 됨.
- 하지만 가장 좋은 방법은 master 브랜치가 자주 변경되지 않게 작업하는 것. 안정적인 버전을 갖고 있어야 하기 때문.

4장. git 원격 저장소

학습 목표
1. 로컬 저장소를 원격 저장소와 연결할 수 있다.
2. 원격 저장소에서 작업 내용을 받아올 수 있다.
3. 원격 저장소에 작업 내용을 반영할 수 있다.

1. 원격 저장소 받아오기

원격 저장소
: 인터넷이나 네트워크 어딘가에 있는 저장소.
- 호스팅 서비스를 이용해 원격 저장소를 만들 수 있음.
  - 호스팅
  : 서버 컴퓨터의 일정 공간을 이용할 수 있도록 임대해주는 서비스.

git 원격 저장소 받아오기
: 원격으로 존재하는 git repositort를 로컬 디렉토리에 복사(클론)해온다.
- git clone &lt;저장소 url&gt; 명령어를 입력.
  - 원격 저장소 url
  : 원격 저장소의 주소.
    - 확인 방법
      - 깃허브 또는 깃랩의 레파지토리에 접근해 clone 버튼을 누름.
      - ssh, https 두 가지 옵션 중 https 항목을 복사.
        - url 구성
          - 예)
          https://gitlab.com/group/project
          : 웹 호스트 서비스/그룹 명/ 프로젝트 명
- 내 컴퓨터에 원격 저장소의 사본이 생성됨.
- git remote &lt;origin&gt; &lt;url&gt; 명령어로 로컬에 복사된 저장소와 원격 저장소를 연결할 수 있음.
  - origin은 원격 저장소 이름의 기본값

원격 저장소 확인
- git remote 명령어로 연결된 원격 저장소가 무엇인지 확인할 수 있음.
- git remote show &lt;origin&gt; 명령어로 어떤 원격 저장소가 존재하는 확인할 수 있음.

원격 저장소 이름 변경
- git remote rename &lt;origin&gt; &lt;git_test&gt;
: &lt;기존 이름&gt; / &lt;새 이름&gt;

원격 저장소 삭제
- git remote rm &lt;origin&gt;
: remove. (어딘가에서) 치우다. 제거하다.
: 주소가 변경되었거나 필요 없어진 저장소를 삭제.

원격 저장소 동기화

저장소 갱신
1. git pull
: 원격 저장소에서 데이터를 가져와 로컬 데이터와 병합한다.
- 로컬 저장소의 master 브랜치와 원격 저장소의 origin master 브랜치가 서로 병합되었기 때문에 하나의 체크 포인트를 동시에 가리키게 됨.
- git log --all
-&gt; commit fffffff (Head -&gt; master, origin/master)

2. git fetch
: 원격 저장소에서 데이터만 가져온다. 진행 중인 작업을 마무리 후 직접 병합해줘야 한다.
- git fetch 명령어로 데이터를 가져옴. master -&gt; origin/master.
- git log 명령어로 변경된 파일을 확인함.
- 로컬 master 브랜치로 전환, git merge origin/master 명령어로 두 데이터의 병합을 진행.
- git log --all
-&gt; commit ffffff (HEAD -&gt; master)
    // 로컬 마스터 브랜치로 병합됨.
    commit ffffff (origin/master)
    // 원격 저장소의 마스터 브랜치를 받아왔음.

저장소 발행
: 로컬 저장소에서 작업한 내용을 원격 저장소에 반영한다.
- git push origin master
  // origin 저장소에 master 브랜치를 반영.
  - 같은 파일을 다른 사람이 먼저 push한 상태에서는 내 파일을 push할 수 없음. 먼저 push된 작업물을 가져와 나의 작업물과 병합해주는 과정이 필요.

origin
: 원격 저장소 이름의 default 값.
- git clone 명령어로 만들어진 원격 저장소의 이름은 origin으로 통일됨.
- git remote add &lt;name&gt; https:... 명령어로 원격 저장소를 연결할 때 저장소의 이름을 다른 이름으로 변경할 수 있음.
- git remote -v 명령어를 사용하면 저장소의 이름과 주소를 확인할 수 있음.

* 별책 부록

git commit --amend
: amend. 개정하다. 수정하다.
: 가장 최근 커밋을 수정한다.
- git commit --amend -m "re"
: 커밋 수정 시 메세지 남기기.
- git commit --am "re"
: 이렇게 축약할 수도 있음.
- 가장 최근 커밋을 수정하는 편리한 방법임.
- 스냅샷을 변경하지 않아도 이전 커밋 메세지를 편집하는 데 사용할 수도 있음.
- 최근 커밋을 완전히 대체함. 가장 최근 커밋을 변경하는 게 아니기 때문에 이전 커밋은 아예 사라져버린다는 점을 주의.

git reset --hard "9d46f1514b36dad6947508ffeb5754330ffb2c2b"
: 온라인 저장소에는 있지만 로컬에서 삭제한 상태인 파일을 복구한다.
- git log 명령어로 복구하려는 파일의 해쉬 값을 확인한다.

mkdir /home/user/new_folder
: 해당 경로에 새로운 디렉토리를 만든다.
- 경로를 설정하지 않으면 현 위치를 기본값으로 한다.

경로
- /
: 루트
- ./
: 현재 위치
- ../
: 현재 위치의 상단 폴더
- 만약 두 단계 상위 디렉토리로 이동하려면 ../../ 이렇게 입력하면 됨.

cd &lt;경로&gt;
: 해당 경로로 이동한다.            
          </pre>
          </div>
          <!-- 사이드바 -->
        <div class="section_sidebar">
        </div>
      </div>
      <div class="bottom"></div>
    </div>
      <script src="javascript/script.js"></script>
  </body>
</html>
