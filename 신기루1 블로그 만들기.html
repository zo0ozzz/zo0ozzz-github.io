<!DOCTYPE html>
<html lang="ko" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>zo0ozzz</title>
    <link rel="stylesheet" href="css/css.css">
  </head>
  <body>
    <div class = "container1">
      <div></div>
      <div class = "container2">
        <!-- 블로그 이름 -->
        <div class="head_blogName">
          <a href = "index.html" class = "h_blogName"></a>
          </div>
        <div></div>
        <!-- 날짜 -->
        <div class="section_head_date">
          <div class="s_h_date">
            2022년 12월 20일 화요일
          </div>
          </div>
        <div></div>
        <div></div>
        <!-- 제목 -->
        <div class="section_head_subject">
          <h1 class="s_h_subject">
            신기루1 블로그 만들기
          </h1>
          </div>
        <div></div>
        <div></div>
        <!-- 본문 -->
        <div class="section_body">
          <br>
          <h2>&lt;ㅇ.ㅇ1&gt; 블로그 구상</h2>

          <p>생활코딩 WEB 강의 마지막 편에서, 다른 언어 공부로 넘어가기보단 지금까지 배운 걸 가지고 뭔가를 만들어보길 권했다. 그래서 만들어보기로 했다.</p>

          <p>- 뭘 만들까 <br><br>
          
          블로그를 만들기로 했다. 내가 생산한 콘텐츠를 내가 원하는 방식으로 보여줄 곳이 있었으면 좋겠다는 생각이 있었다. 일상에서도 뭔가를 내 마음에 들게 구성하는 데 노력을 많이 쏟는 편이다. 일하는 공간을 꾸민다든가 컴퓨터 프로그램 스킨을 바꾸는 일들. 그런 일에 재미를 느끼는 타입인 것 같다. 뭔가가 마음대로 되지 않으면 해결 방법을 찾느라 하루를 다 써버리기도 한다. 그냥 적당히 해도 되는데. <br><br>
          
          네이버, 티스토리, 이글루스, 구글 블로거 등을 이것저것 건드려봐도 꼭 뭔가 하나씩 내 취향을 투사시킬 수 없는 부분이 있었다. 그렇다고 html을 수정해보자니 이거야 아득해졌다. 능력 부족인 것이다. <br><br>
          
          github 블로그로 내가 필요한 기능만 탑재한 홈페이지를 만드는 건 해낼 수도 있을 것 같다. 많은 사람들이 부분부분의 설명서를 공유해놓았을 테니까. 고마우신 분들과 내 검색 능력을 믿고 가는 수밖에 없다.</p>
          
          <p>- 구현하려는 것들 <br><br>

          디자인적으로는 이전에 생각해뒀던 게 있긴 한데, 지금 쓰는 구글 블로거 디자인도 아주 씸플한 게 마음에 들어서 둘 중에 고민이다. 화면에 블로그 이름, 콘텐츠 하나, 분류 기준에 따라 묶인 목록들만 보이게 할 것. 개인적으로 여백이 많은 디자인이 좋다. <br><br>
          
          기능적으로는 <br><br>
          
          1. 콘텐츠를 콘텐츠 자체의 성격에 따라 묶는 기능(일반적인 카테고리) <br><br>
          2. 발행일을 기준으로 월별로 묶는 기능 <br><br>
          3. 일부 카테고리는 콘텐츠를 시간의 역순으로 정렬하는 기능 <br><br>
          
          다른 블로그 서비스에 이미 있는 기능들도 있지만, 연습 삼아 직접 구현해보는 게 도움이 될 거라 생각한다. 언젠가 어느 서비스도 지원하지 않는 나만의 괴상한 방법으로 콘텐츠를 카테고리화하고 싶어질지도 모르니까. 뭐 콘텐츠 중에 홀수 번호만 모아놓는다든지. </p>
          
          <p>- 건설 수단 <br><br>

          html, css, javascript. 애초에 이것밖에 모른다.</p>
          
          * <br><br>
          
          <p>써놓고 보니 목표가 실력에 비해 너무 거창한 것 같다. 해낼 수 있으려나..</p>
          
          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ2&gt; 블로그 레이아웃 짜기</h2>          
          
          <p>(<br>
          기록을 어떤 식으로 해야 할지 확신이 안 선다. 도움이 필요하면 검색해보는 블로그들처럼 완벽한 설명서처럼 써야 할지.. 나는 아직 아는 게 별로 없어서 해당 개념을 공부하고 -&gt; 거기에 엮여 있는 모든 걸 다 설명하고 정리하려다가는 시간이 엄청 걸릴 것 같다. 시간이 남아 돌아 펑펑 써버릴 때가 있었는데.. 어느 순간부터는 항상 시간이 발목을 잡는다. 종종 후회가 된다. <br><br>
          
          이런저런 고민을 해봤는데, 고민만 하다가는 한 걸음도 못 뗄 것 같아서 일단 마음 가는 대로 써보기로 했다. 새로 배우는 개념을 전부 정리하는 것보단 그중에서 내가 사용한 것 위주로만 적어볼 생각이다. 지인에게 그날의 경험담을 들려준다거나 어쩌다 보니 덜컥 미지의 구역에 들어서게 된 초보 여행자의 심정으로 쓰자고 다짐하니 마음이 좀 편해진다. <br>
          )</p>
          
          <p>생활코딩 강의에서 css grid를 배웠던 게 있어서 grid를 활용해보기로 하고 레이아웃을 그려봤다. <br><br>
          
          <!-- 설게도(1) -->
          
          화면에 표시할 항목들을 정하고(블로그 이름, 제목, 본문, 카테고리 사이드바) 배치했다. 네모네모한 공간들을 9등분해서 쑉쑉 넣어주면 되겠다 싶었다. 다음으로 벌써 희미해져버린 gird 지식을 검색을 통해 업데이트하기로 했다.</p>
          <p>( <br>
          모르는 걸 검색하다 보면 내가 찾던 그것을 정말이지 상세히 알려주는 수많은 자료를 만나게 된다. 그런 자료의 생산자들은 어떤 이유로 그런 자료를 작성하는 걸까? 어떤 글은 정말 책으로 내도 될 정도로 퀄리티가 상당한데, 딱 봐도 거기에 들어간 시간과 정성이 장난이 아닐 것 같다. 역시 페이지 광고 수익이 원동력일까..? 그렇게 많이 벌리나..? 자기만족이거나 자기 홍보 또는 다른 사람들한테 도움이 되고 싶어서일 수도 있겠다. 아니면 그냥 공부 목적이거나. 하긴 나도 뭘 적고 있긴 하네. 아무튼 대단한 일이다. 일면식도 없지만 그 사람의 의도가 어떻든 나의 이정표가 되어줬다는 데 문득 고마운 마음이 든다. <br>
          )</p>
          
          <p>검색어: css grid <br><br>
          
          &lt;div&gt;&lt;/div&gt;를 이용해 grid에 통제받을 구역을 생성한다. 상위 &lt;div&gt;&lt;/div&gt;가 하위 &lt;div&gt;&lt;/div&gt;들을 포함하고 있다. grid 명령은 상위 &lt;div&gt;&lt;/div&gt;를 붙잡고 하달한다. 그러면 하위 &lt;div&gt;&lt;/div&gt;들이 일사분란하게 지시에 따라 움직인다. <br><br>
             
          display: grid; <br><br>
          -&gt; grid 기능 on <br><br>
          
          grid-template-columns: ; <br><br>
          -&gt; 해당 구역을 속성값들의 개수만큼 나눔. 횡으로 배열. <br><br>
          
          grid-template-rows: ; <br><br>
          -&gt; 해당 구역을 속성값들의 개수만큼 나눔. 종으로 배열. </p>
          
          <p>코드:
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;div class="Container"&gt;

    &lt;div&gt;1(블로그 이름)&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;div&gt;4&lt;/div&gt;
    &lt;div&gt;5(제목)&lt;/div&gt;
    &lt;div&gt;6&lt;/div&gt;
    &lt;div&gt;7&lt;/div&gt;
    &lt;div&gt;8(본문)&lt;/div&gt;
    &lt;div&gt;9(카테고리 사이드바)&lt;/div&gt;

    &lt;/div&gt;          
</code>
</pre>
          
          명령에 따라 움직일 &lt;div&gt;&lt;/div&gt;들을 만들어주고
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;style&gt;
div{
  border: 1px solid;
}

.Container{
  display: grid;
  grid-template-columns: 1fr 500px 1fr;
  gird-template-rows: 1fr 1fr 1fr;
}
&lt;/style&gt;
</code>
</pre>

          grid 기능을 켜준다. 본문 가로폭은 일단 500px로 지정했고, 표시될 내용들을 전체적으로 화면 중앙에 위치시키고 싶어 고민하다 날개 칸 가로폭은 각각 1fr로 지정했다. <br><br>
          
          nfr(n에는 숫자) <br><br>
          -&gt; 길이 중 픽스된 길이을 제외한 나머지를 일정한 지정한 비율로 나눠가진다. <br><br>
          -&gt; 상대값이기 때문에 창 크기가 달라지면 그때그때 길이가 변한다. <br><br>
          
          세로 폭은 아직 감이 안 잡혀서 1fr 1fr 1fr로 해줬다. 차차 이쁘게 조정할 생각. <br><br>
          
          결과: <br><br>
          
          <!-- 이미지 -->
          
          </p>

          <p>전체 화면을 아홉 개 구역으로 나누는 건 성공했다! 그런데 아뿔싸, 창 크기를 줄여보니 1fr를 먹인 구역 내용의 형태가 찌그러졌다. 반면 가로폭을 픽스해준 가운데 구역은 창 크기가 작아지면 가려지긴 했지만 형태가 무너지진 않았다. 부러질지언정 굽히진 않는 것이다. 다른 구역도 형태가 망가지지 않게 만들고 싶었다. 해결책은 <br><br>
          
          1. 양쪽 공간에도 가로폭을 지정해주기 <br><br>
          2. 가운데 배치를 유지하기 위해서 양쪽에 추가로 1fr의 공간을 만들어주기. <br><br>
          
          ㄱㄱ! </p>
          
          <p>코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;div class="Container"&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2(블로그 이름)&lt;/div&gt;
&lt;div&gt;3&lt;/div&gt;
&lt;div&gt;4&lt;/div&gt;
&lt;div&gt;5&lt;/div&gt;
&lt;div&gt;6&lt;/div&gt;
&lt;div&gt;7&lt;/div&gt;
&lt;div&gt;8(제목)&lt;/div&gt;
&lt;div&gt;9&lt;/div&gt;
&lt;div&gt;10&lt;/div&gt;
&lt;div&gt;11&lt;/div&gt;
&lt;div&gt;12&lt;/div&gt;
&lt;div&gt;13(본문)&lt;/div&gt;
&lt;div&gt;14(카테고리 사이드바)&lt;/div&gt;
&lt;div&gt;15&lt;/div&gt;

&lt;/div&gt;
</code>
</pre>
              
          &lt;div&gt;&lt;/div&gt;iv들이 무려 15개가 됐다. 코딩을 잘 알진 못하지만 뭔가 쓸데없이 많아 보이긴 한다. 이런 느낌은 다른 분야에서의 경험상 뭔가 개선이 가능하다는 걸 의미할 텐데.. 그치만 일단 냅두고.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;style&gt;
    div{
      border: 1px solid;
    }

    .Container{
      display: grid;
      grid-template-columns: 1fr 200px 300px 200px 1fr;
      grid-template-rows: 1fr 1fr 1fr;
    }
    &lt;/style&gt;          
</code>
</pre>
            
          결과:
          
          <!-- 이미지 -->
          </p>
          
          <p>오예~ 됐다. 이제 창 크기가 좁아져도 글자가 찌그러지지 않고 표시할 내용도 화면 가운데에 잘 위치해준다. 이제 예쁘게 만들어줄 차례다.</p>
          
          <p>이 상태로 뚝딱뚝딱 꾸며보다가 몇 가지를 수정했다. <br><br>
          
          1. <br><br>
          블로그 이름을 아무데나 위치시켜주고 싶어서 맨 위쪽을 나뉘지 않은 하나의 공간으로 만들어줬다. <br><br>
          
          grid-column-start: n; <br><br>
          grid-column-end: n; <br><br>
          -&gt; 그리드로 나뉘는 한 칸의 형태를 지정해준다. 예를 들어 2번째 줄부터 5번째 줄까지를 차지하는 칸을 만들고 싶다면, 그 칸을 선택하고 start 속성의 속성값으로 2 end 속성의 속성값으로 5를 입력해준다. <br><br>
          -&gt; 세로 칸의 공간을 지정하고 싶다면 column을 row로 바꿔준다. <br><br>
          
          2. <br><br>
          양쪽 날개 칸이 굳이 여러 칸으로 나뉘어질 필요가 없어서 하나의 칸으로 만들어줬다. Container1로 전체 모양을 잡고 그 안에 Container2를 만들어 보여질 내용을 담기로 했다. Container2를 다시 grid로 나누어 내용들을 적절한 위치에 배치했다. <br><br>
          
          3. <br><br>
          본문의 마지막 줄 밑으로는 스크롤이 안 됐다. 본문이 표시되는 데는 문제가 없었지만 보기 편한 위치로 이동시키는 게 불가능한 것이다. 본문의 끝 부분에서 스크롤이 좀 더 내려갈 수 있게 하려고 고민하다가 맨 밑에 한 칸을 더 만들기로 했다. 세로 폭은 우선 1fr로 지정해놨는데, 계속 스크롤을 내리면 화면이 거의 텅 비어버려서 아무래도 최선은 아닌 것 같다. 사용해보다가 적당한 길이로 다시 지정해주기로 했다. </p>
          
          <p>구상: 

          <!-- 이미지 -->
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;style&gt;
div{
  border: 1px solid;
}
.Container1{
  display: grid;
  grid-template-columns: 1fr 800px 1fr;
  grid-template-rows: 1fr 1fr;
}

.GridBottom{
  grid-column-start: 1;
  grid-column-end: 4;
}

.Container2{
  display: grid;
  grid-template-columns: 175px 450px 175px;
  grid-template-rows: 150px 25px 30px 1fr;
}

.BlogNameSpace{
  grid-column-start: 1;
  grid-column-end: 4;
}
&lt;/style&gt;

&lt;body&gt;
&lt;div class = "Container1"&gt;

  &lt;div&gt;&lt;/div&gt;
  &lt;div class = "Container2"&gt;

    &lt;div class="BlogNameSpace"&gt;
      블로그 이름
      &lt;/div&gt;
    &lt;div class=""&gt;&lt;/div&gt;
    &lt;div class="DateSpace"&gt;
      날짜
      &lt;/div&gt;
    &lt;div class=""&gt;&lt;/div&gt;
    &lt;div class=""&gt;&lt;/div&gt;
    &lt;div class="SubjectSpace"&gt;
      제목
      &lt;/div&gt;
    &lt;div class=""&gt;&lt;/div&gt;
    &lt;div class=""&gt;&lt;/div&gt;
    &lt;div class="ContentSpace"&gt;
      본문
      &lt;/div&gt;
    &lt;div class="SidebarSpace"&gt;
      사이드바
      &lt;/div&gt;

    &lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div class="GridBottom"&gt;&lt;/div&gt;

  &lt;/div&gt;
&lt;/body&gt;
</code>
</pre>
          
          결과: 
          
          <!-- 이미지 -->
          </p>
          
          <p>grid로 구역 나누기가 드디어 끝났다! 야호~ 익숙하지 않으니 결과값이 잘 예측이 안 돼서 꽤 오랜 시간이 걸렸다. <br><br>
          
          이제 각 요소들을 세부적으로 조정해줬다. 형태만 잡아주면 나머지는 간단히 끝날 줄 알았는데, 마음에 들 때까지 고치고 또 고치다 보니 이 단계에서도 시간이 좀 걸렸다. 그렇게 나온 쌤플 페이지는 바로바로~~~ <br><br>          
          
          <!-- 이미지 -->
          
          ㅋㅋㅋ 깔끔해서 마음에 든다! 최대한 본문에 집중할 수 있는 페이지를 만들자는 의도였다. 어느 정도 성공한 것 같긴 한데 음.. 아무래도 코딩 기록보단 소설이나 수필 같은 글에 맞는 디자인인 것 같기도 하고.. 뭐 이제 대충 할 줄 알게 됐으니 더 좋은 디자인이 생각나면 또 바꾸면 되는 것이다~ 기분이 좋다. <br><br>
          
          전체적인 형태를 잡을 때 사용한 grid 말고도 구체화시키는 과정에서 css 기능 구현에 대해 검색을 많이 했다. 이제 어떤 식으로 검색해서 무엇을 배워와야 하는지 좀 알 것도 같다. 사용했던 기능 중에 몇 가지 적어둔다. </p>
          
          <p>1. web font
          
          <!-- 이미지 -->
          
          -&gt; 구글폰트나 눈누에서 웹폰트 url을 복사해와 style 태그 안에 붙여넣으면 된다. <br><br>
          -&gt; 위의 link, @import 방식 중에 link 방식이 더 낫다고 한다. 속도 면에서 더 빠르다고. link는 &lt;head&gt; 태그 안에, @import는 &lt;style&gt; 태그 안에 써준다. <br><br>
          -&gt; 적용할 때는 폰트명을 정확히 적어줘야 한다. 폰트명에 띄어쓰기가 있으면 +로 붙여주면 되는데, 보통은 띄어쓰기가 있는 채로 따옴표 안에 넣어주는 모양이다. 아무래도 오류가 나면 안 되니까 그렇겠지? </p>
          
          <p>2. font <br>
          -&gt; 폰트 크기를 조정하려고 font: 13px; 정도로 계속 해봤는데도 적용이 안 됐다. 검색해보니 폰트 크기만 변경하려면 font-size: ; 명령어를 써야 했다. <br>
          -&gt; font: ;로는 폰트의 각종 속성값을 한 번에 조정할 수 있다. 중요한 건 속성값을 주는 데 지켜야 할 점이 있다는 것. <br>
          -&gt; font: ;에는 폰트 크기와 폰트명이 반드시 들어가야 한다. 그중 폰트명은 맨 끝에 써줘야 한다. 폰트 스타일(weight 등)은 폰트 크기 앞에 써준다. 즉, font: italic 13px 'Arial'; 이런 순서로 써줘야 한다. <br>
          -&gt; italic을 계속 ltalic이라고 써서 적용이 안 됐다. 바보 같은 놈. </p>
          
          <p>3. padding &amp; margin <br>
          -&gt; padding은 해당 요소의 안쪽, margin은 해당 요소의 바깥쪽 공간을 의미. <br>
          -&gt; 방향에 따라 padding-top, right, bottom, left으로 사용할 수 있다. <br>
          -&gt; 속성값을 padding: ;에 한 번에 쓰고 싶을 때는 앞선 순서대로 써야 한다. <br>
          -&gt; padding: a / 네 방향 각각 동일한 속성값 적용 <br>
          -&gt; padding: a b / 상하, 양옆 각각 속성값 적용 <br>
          -&gt; padding: a b c / 상, 양옆, 하 각각 속성값 적용 <br>
          -&gt; padding: a b c d / 네 방향 각각 속성값 적용 <br>
          -&gt; margin도 같은 방식으로 사용 </p>
          
          <p>4. display: inline; / block; / inline-block; <br>
          -&gt; display: inline; 은 요소 자체만큼만의 구역을 차지하게 한다. width, height, margin, padding 상하 조정이 안 먹힌다. 좌우 조정은 가능. 줄바꿈X <br>
          -&gt; 상하 조정이 안 된다는 걸 몰라서, 제목 위의 작성 날짜 요소의 위치를 조정할 때 엄청 짜증났다. 알고 보니 원래 안 되는 거였다.. <br>
          -&gt; display: block; 은 요소가 위치한 공간의 한 줄 전체를 다 차지한다. margin, padding이 모두 기능한다. 줄바꿈O <br>
          -&gt; display: inline-block; 은 요소 자체만큼만의 구역을 차지하면서 width, height, margin, padding 조정이 모두 먹힌다. 줄바꿈X </p>
          
          <p>5. background-color: ; &amp; color: ; <br>
          -&gt; 앞에 건 배경 색 조정 <br>
          -&gt; 뒤에 건 text 색 조정 </p>
          
          <p>6. &lt;h1&gt; tag <br>
          -&gt; 처음에는 당연히 블로그 이름에 &lt;h1&gt; 태그를 썼다. 뭔가.. 왠지 모르게 그게 당연한 것 같았다. <br>
          -&gt; 별 생각 없이 레이아웃을 꾸미다, 어.. 근데 블로그 이름에 &lt;h1&gt; 태그를 왜 쓰지..? 라는 의문이 들었다. 생활코딩 강의에서 &lt;h1, 2, 3...&gt; 태그들에 대해 무슨 검색에서 걸리고 그런 얘기를 들은 것 같았다. 블로그 이름 &lt;h1&gt; 태그, 라고 검색했다. <br>
          -&gt; 검색 관련해서 SEO(Search Engine Optimization)라는 게 있다고 했다. 내가 이해하기론 써치 엔진이 유저의 검색어와 콘텐츠의 연관지어내는 데 &lt;h1&gt; 태그 안에 들어가 있는 내용을 활용한다, 뭐 이런 설명인 것 같았다. 그래서 &lt;h1&gt; 태그는 하나만 있는 게 좋다고. 남발하면 제아무리 써치 엔진이라도 뭐가 콘텐츠의 핵심 내용인지 헷갈려버리는 것이다. 그러니까, 어떤 콘텐츠를 검색 시스템에 잘 걸리게 하려면 &lt;h1&gt; 태그를 가능한 적게 쓰는 게 좋다는 설명. h1 h2 h3... 숫자가 커질 수록 써치 엔진에 대한 영향력이 작아진다. <br>
          -&gt; 생각해보면 블로그 이름이 검색에 걸리게 할 필요는 없다. 그건 굉장히 다양한 것들을 품어야 하는 너무 큰 범주라서 아예 내용이랑은 상관없어져버려도 그만이니까. 예를 들어 나는 정웅비, 라는 이름을 갖고 있지만 그게 내가 어떤 사람인지에 대해선 요만큼도 알려주지 못하는 것이다. 그렇지 않다면 이력서에 그냥 이름만 써도 되겠지. <br>
          -&gt; 주절주절 이야기가 길었는데, 블로그 이름처럼 검색에 걸릴 필요가 없는 요소들은 그냥 텍스트로 적어도 될 것 같다. 선택할 수 있게 해야 한다면 &lt;span&gt;&lt;/span&gt; 정도로 감싸주기만 해도 충분할 듯! </p>
          
          <p>대학생 때 거의 격월간 몰라도 되는데, 라는 잡지 동아리를 했었다. 그때 기사 레이아웃을 잡는 데 고민을 많이 했었는데, 이렇게 몇 년이나 지나 다시 레이아웃에 대해 골똘히 생각하게 될 줄 누가 알았을까.. 뭐 그때는 기사 페이지를 죄다 손으로 쓰고 그렸지만. 생각해보면 꽤 특이한 동아리였다. 컴퓨터가 널렸는데 페이지를 손글씨와 그림으로 채우고 스캔해서 책으로 발간해대다니.. 재밌는 시절이었다. 최근에도 동아리를 같이 했던 형이랑 만나 고추잡채에 술을 진탕 마셨다.</p>
          
          <p>아무튼 블로그 레이아웃 만들기를 끝냈다~ 다음으로는 javascript로 블로그 곳곳에 들어갈 기능을 만들어보겠다!</p>
          
          <p>

          <!-- 이미지 -->
          
          이건 다른 디자인으로 만들어본 블로그!
          읽을 때 방해되는 요소를 최대한 줄이려고
          본문을 왼쪽에 사이드바를 오른쪽에 붙여버렸다!
          더 진행하진 않을 거지만 기념으로 여기 전시해본다~ </p>
          
          <P>전체 코드:
          
          <!-- 코드 -->
          
          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ3&gt; 콘텐츠를 특정 기준으로 분류하기</h2>
          
          <p>분류 측면에서 내가 구현하려 했던 기능은 크게 세 가지였다. <br><br> 
          
          1. 전체 콘텐츠 목록 보여주기 <br>
          2. 글의 성격에 따라 카테고리별로 목록 보여주기 <br>
          3. 발행일 기준으로 1개월씩 묶어서 목록 보여주기 

          <!-- 이미지 -->
          
          이런 식의 구성을 생각했다. <br><br>
          
          일단 기능 구현 시도에 사용될 실험용 콘텐츠를 6개 작성했다. <br><br>
          
          데자와, 솔의눈, 제로코크, 수성, 금성, 지구 <br><br>
          
          각 콘텐츠는 데자와.html 같은 형태로 html 문서화시켜 저장했다. <br><br>

          <!-- 이미지 -->
          
          </p>
          
          <p>내가 세운 작전은 이랬다. 이렇게 저렇게 해서 배열을 만든다! 분류 기준에 맞는 배열만 만들어내면 목록화는 반복문으로 쫘좌좍 뽑아주면 될 것이었다. 아~ 쉽다 쉬워~ </p>
          
          <p>첫 번째 기능(전체 콘텐츠 목록 보여주기)를 위해 전체글 배열을 만들었다. <br><br>
          
          코드:
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const 전체글 = ['데자와', '솔의눈', '제로코크', '수성', '금성', '지구'];
</code>
</pre> 
          
          이제 두 번째 기능(글의 성격에 따라 묶인 목록 보여주기)에 사용된 배열을 만들어줄 차례다. 가장 간단하게는 <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const 수필 = ['데자와', '솔의눈', '제로코크'];
const 행성 = ['수성', '금성', '지구'];
</code>
</pre>
              
          이렇게 하나하나 써서 각 배열을 만들어주면 된다. <br><br> 
          
          하지만 그렇게 만들려면 굳이 javascript를 사용할 필요가 없다. 내 생각에 (잘 모르지만) javascript라는 것의 의미는 자동화, 인 것 같다. 하드 코딩의 귀찮음을 그리고 때로는 그것의 방대함에 따른 불가능을 해결하기 위해 (아마도) 고안된 도구인 것이다! 이를테면 하나의 요소를 추가하면 그게 자기 자리에 알아서 위치해주는.. 그런 걸 가능하게 하는 거랄까.. 뭐 아무튼. <br><br>
          
          전체글, 이라는 배열에 있는 요소들 중 수필, 이라는 배열에 들어갈 요소들을 어떻게 뽑아올까.. 나는 이렇게 하기로 했다. 전체글 배열의 각 요소에 id값을 주고, 그 id값으로 수필 배열에 들어갈 요소를 데려오자! 이 작전을 코드로 나타내자면 이렇다. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const 전체글 = ['id = "수필" 데자와', 'id = "수필" 솔의눈', 'id = "수필" 제로코크', 'id = "행성" 수성', 'id = "행성" 금성', 'id = "행성" 지구'];

const 수필 = [전체글 중 "수필"이라는 id값을 가진 요소들만 뽑아온다!]
</code>
</pre>
          
          그러나.. 계속되는 검색에도 배열의 요소에 id값을 주는 방법은 전혀 나오지 않았다. 못 찾았다기보다는 애초에 틀려먹은 생각이었던 것 같다. 멍청한 놈.. <br><br>
          
          이번엔 처음부터 카테고리로 배열을 만들고 모든 배열을 합쳐서 전체글 배열을 만들어내기로 했다. 새로운 콘텐츠가 추가될 때마다 해당하는 카테고리에 추가해주면 전체글에도 자동으로 반영될 테니, 이렇게 하는 것도 나쁘지 않겠다는 생각이 들었다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const 수필 = ['데자와', '솔의눈', '제로코크'];
const 행성 = ['수성', '금성', '지구'];
</code>
</pre>
               
          서로 다른 배열을 합치는 방법을 검색. <br><br>
          
          검색어: javascript array plus <br><br>
          
          array1.concat(array2); <br>
          -&gt; 배열1의 끝에 배열2의 요소를 추가해 새로운 배열을 만든다. <br><br>
          
          그렇게 탄생한 전체글 배열.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
수필.concat(행성); 
-&gt; const 전체글 =  ['데자와', '솔의눈', '제로코크', '수성', '금성', '지구'];
</code>
</pre>
              
          됐다! 라는 기쁨도 잠시였다. 이렇게 단순히 배열1의 끝에 배열2를 붙여 만든 배열로는 콘텐츠의 시간상 선후 관계를 반영할 수가 없었다ㅠㅠ. 그러니까, '지구'가 1월 1일에 '제로코크'가 1월 2일에 '데자와'가 1월 3일에 발행됐다고 한다면, 나는 요소가 '데자와', '제로코크', '지구' 순으로 나열된 배열이 필요한 것이다.. 이 다음에 만들 세 번째 기능(발행일 기준으로 월별로 모으기)에 순서가 중요한 건 뭐 말할 것도 없고.. <br><br>
          
          콘텐츠의 성격 속성과 작성 시간 속성을 모두 갖춘 배열을 어떻게 만들 수 있을까.. <br><br>
          
          고민.. 고민.. <br><br>
          
          음.. 객체를 만들어 시도해보기로 했다! <br><br> 
          
          이 작전의 핵심 아이디어는 목표물에 접근하는 과정에서 두 개의 필터(key)를 거치게 하는 것이다! <br><br>
          
          시도에 앞서 콘텐츠를 몇 가지 더 추가해줬다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// 전체글 객체
const 전체글 = {  
    ['20221212'] : {
      음료 : ['데자와'],
      행성 : ['수성']
    },
    ['20221010'] : {
      음료 : ['솔의눈'],
      행성 : ['금성', '지구']
    },
    ['20220303'] : {
      음료 : ['제로코크'],
      행성 : ['목성', '토성']
    },
    ['20220330'] : {
      음료 : ['하늘보리']
    },
    ['20220101'] : {
      행성 : ['천왕성', '달']
    }
  }  
</code>
</pre>
                    
          '전체글' 객체의 key를 콘텐츠 작성일 여덟 자리로 설정했다. key의 값(value)으로 다시 객체를 선언하고 그 객체의 key로 카테고리 이름을 줬다. 그리고 그 key의 값(value)엔 작성일, 카테고리 이름에 해당하는 콘텐츠를 배열 형식으로 입력했다 <br>
          전체글 -&gt; 작성일 -&gt; 카테고리 -&gt; 찾는 요소 <br><br>
          
          '전체글' 객체를 이런 구조로 만들어놓으면 두 개의 분류 기준 즉, 작성일과 카테고리라는 분류 기준을 가지고 그것을 만족하는 콘텐츠를 찾아낼 수 있을 것이다! 사실 아직은 찾아낼 수 있을 걸로 예상된다, 정도의 단계이긴 하지만..! <br><br> 
          
          아무튼 핵심 아이디어는 목표물로 가기 전에 두 개의 필터(키)를 거치게 하자는 것! <br><br>
          
          * 객체의 key <br>
          -&gt; key는 문자(string)가 사용된다. <br>
          -&gt; key로 사용될 문자는 숫자로 시작되면 안 된다. 예) 8월의 크리스마스 <br>
          -&gt; key는 기본적으로 ['key'] 형태로 입력한다. 하지만 포장을 생략해도 된다. <br>
          -&gt; 굳이 숫자를 key로 쓰려면 ['8282'], ['8월의 크리스마스'] 이렇게 포장을 해줘야 한다. 대괄호와 작은따옴표가 string으로 강제 변환해주는 모양이다. 권장되는 방식은 아닌 것 같다. 검색해봤는데 권장되지 않는 이유는 모르겠다. 오류 가능성이 커져서.. 겠지? <br><br>
          
          나는 굳이 key를 숫자로 만들어냈다! 이따 콘텐츠를 1개월 단위로 묶을 때 key로 연산을 해야 할 것 같아서..! 처음엔 안 돼서 당황하다가 key를 숫자로 만드는 방법을 찾아 한참을 헤매 결국 성공했다. 근데 이제 와 생각해보니 key를 정하는 과정에서 number를 string으로 변환했을 텐데 이따가 string끼리 연산이 가능할까..? 음.. 일단 해보기로 했다. </p>
          
          <p>카테고리별로 콘텐츠 배열 만들기 <br><br>
          
          1. 전체글 배열 만들기 <br><br>
          
          전체글 객체에서 작성일 순서에 따라 모든 글을 찾아내야 한다. 사용할 함수를 만들어보자! <br><br>
          
          코드: 

          <!-- 이미지 -->
          
          함수를 제조하면서.. 참 많은 일들이 있었다.. 예를 하나 들자면, 강의를 들을 때는 아 이런 게 반복문이구나~ 오케이 오케이 완전 알았어~ 라고 생각했는데, 그저 이해하면 그만인 시기를 지나 직접 사용해보려니 이거야 뭐 제대로 아는 게 없었다. 역시 이해와 활용은 꽤나 다른 차원의 문제인 것이다. <br><br>
          
          미궁 안의 미노타우르스마냥, 한동안 뱅글뱅글 도는 반복문 안에 갇혀버렸다. 부끄럽지만  빠져나오지 못하던 시간이 좀 길었다. 반복문으로 이렇게 저렇게 하면 뭔가 만들어낼 수 있겠는데? 라는 생각으로 반복문을 짜냈지만, 정작 반복의 결과물을 밖으로 가지고 나오는 방법을 몰랐던 것이다.. <br><br>
          
          아무리 수정해도 document.write()에 넣어보면 계속 값이 하나만 나왔다. console.log에는 분명히 찍히는데. 이거야 뭔가에 홀린 게 아닌가.. 급한 대로 작은 굿이라도 벌여야 하나.. 라는 심정이었다. 지금 와서 생각해보면 너무 당연한 일이었다. 차례차례 반복문이 다 돌아가고 맨 마지막 반복으로 나온 값만 출력된 거니까.. 바보.. <br><br>
          
          생활코딩의 반복문 챕터 강의를 다시 듣고 이것저것 검색을 해봤다. 그리고 드디어.. 원하던 값을 데리고 빙빙 돌아가는 회전목마 같던 반복문에서 탈출해낼 수 있었다. 반복문 밖에 변수를 선언하고 그걸 반복문 내부에서 가공해 밖으로 꺼낼 수 있는 장치를 만들어줘야 한다는 걸 드디어 깨달아낸 것이다..! <br><br>
          
          나의 멍청함이 놀라워 쓸데없는 소리를 너무 주절댄 것 같다. 다시 돌아와, 전체글을 원하는 규칙에 따라 배열로 나타내는 코드를 짜며 알게된 것들을 기록해놓겠다. <br><br>
          
          1. 반복 연산의 결과를 반복문 밖으로 꺼내오기 <br>
          -&gt; 변수는 뭔가(값)를 담는 그릇이라고 생각하면 될 것 같다. 아니.. 어차피 값을 담으니까 값 자체라고 봐도 되나..? <br> 
          -&gt; 반복문 안에서 최초로 선언된 변수는 반복문 밖에서 호출해 사용할 수 없다. 유효 범위의 문제로, 반복문이 끝나는 지점에서 반복문 안에서 태어난 변수 또한 같이 스러져버리고 마는 것이다. 그래서, <br>
          -&gt; 먼저 반복문 밖에다 변수를 선언해주고, 반복의 결과가 차례차례 그 변수에 반영돼 변수 스스로가 반복문 안에서 가공(변화)되게 할 방법을 고안해내야 한다. <br>
          -&gt; 예를 들어 concat()으로 반복의 결과를 변수 안에 계속 축적해낸다든지. <br>
          -&gt; 그렇게 가공된 변수를 리턴한다. <br><br>
          
          이건 좀 다른 얘긴데, 반복문을 다루면서 매일매일을 좀 더 잘 보내야겠다는 생각을 했다. 한 회차 한 회차 반복이 진행되며 반복의 결과가 변수에 반영되고 변수가 변화하는 것처럼, 나 또한 나의 하루하루가 반영되어 변해갈 테니까. 과거의 내가 보낸 하루들을 적분하면 결국 현재의 내가 되는 것이다. 하찮은 일들을 쌓아가면 나도 하찮은 사람이 될 거다. 반면 멋진 일을 쌓아간다면 나도 멋져질 수 있을 거다. <br><br> 
          
          지금의 나는 솔직히 조금 실망스럽다. 그치만 사나이 정웅비와 코딩이 결합한 이상.. 이거 모른다. 열심히 해봐야지. 내 자신이 이뻐 죽을 정도의 내가 되어낼 수 있었으면 좋겠다. 으아아아아!!! 정웅비 파이팅!!! </p>
          
          2. 객체의 요소에 접근하는 방법. 점(.), 대괄호([]) <br>
          -&gt; 객체명.key 혹은 객체명[key] 표기법으로 key의 값에 접근할 수 있다. object-property-property value. <br>
          -&gt; 객체 안에 또 객체가 있다면, 객체명.key.key2 혹은 객체명[key][key2] 이렇게 접근할 수 있다. <br>(object-property)-property-property value. <br>
          -&gt; 처음엔 (for-in + for)문 안에 점(.) 표기법을 썼다. 전체글.key.Categories[i] 이렇게. 그러니까, <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
for(let key in 전체글){
  for(i = 0; i &lt; Categories.length; i++){
      a = a.concat(전체글.key.Categories[i])
  }

</code>
</pre>
          
          -&gt; 근데 계속 오류가 났다. 왜왜왜! 제대로 썼잖아! 머리를 쥐어뜯다가 대괄호 표기법으로 바꿔봤다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
for(let key in 전체글){
  for(i = 0; i &lt; Categories.length; i++){
      a = a.concat(전체글[key][Categories[i]])
  }
</code>
</pre>
          
          -&gt; 작동ㅠㅠ! <br><br>
          
          검색어: javascript 점 대괄호 차이 <br><br>
          
          에 따르면 key를 property로 인식하느냐 변수명으로 인식하느냐에 차이라고 한다. 대괄호 표기법이 작동 범위가 더 넓으니 일반적인 경우엔 대괄호 표기법을 사용하면 될 것 같다! </p>
          
          <p>3. undefined <br>
          -&gt; 반복문으로 가공된 변수(a)를 document.write();로 출력했더니 중간중간 undifined가 표시되었다. 천왕성, undefined, 달, 제로코크 이런 식이었다. 반복문으로 접근했다가 그 자리에 요소가 없으면 값이 undefined로 나오고 그게 그대로 배열에서 한 자리 차지한 채 출력되는 것이다. <br>
          -&gt; 이걸 어떻게 빼나 고민하다가 <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
if(전체글[key][Categories[i]] !== undefined){
</code>
</pre>
              
          를 추가해줬다. undfined가 아니면 다음 프로세스를 진행하라는 뜻. <br> 
          -&gt; 해결됐다! </p>
          
          <p>4. !== <br>
          -&gt; 앞에 느낌표를 써주면 '같지 않다'가 된다. !===에 대한 검색 결과가 없는 걸 보니 !===는 안 쓰는 모양. </p>
          
          <p>5. key를 숫자로 했을 때의 문제점 <br>
          -&gt; 나중에 key로 연산이 필요할 거라는 생각에 key를 굳이 숫자로 해줬다. 여기까지는 좋았다. <br>
          -&gt; 그런데 숫자 key를 가지고 반복문으로 배열을 만드니 요소들이 내가 원했던 것과 정반대의 순서를 가지고 나왔다. 그러니까, 나는 [데자와, 수성, 솔의눈, 금성 ... 천왕성, 달] 이렇게 최신 콘텐츠가 맨 앞에 오는 배열을 만들고 싶었는데, [달, 천왕성 ... 금성, 솔의눈, 수성, 데자와] 이런 식으로 가장 오래된 콘텐츠가 맨 앞에 나오는 것이다. <br>
          -&gt; key로 숫자를 쓰면 무조건 작은 값부터 큰 값으로 연산이 진행되는 모양이다. <br>
          -&gt; 일단 배열을 거꾸로 뒤집어주는 방법을 찾아봤다. 하지만 이 방식의 문제는 앞으로 제작하는 모든 함수의 끝에 이걸 적용해줘야 한다는 것. <br>
          -&gt; 더 효율적인 방법, 그러니까 한 번만 손봐주면 되는 방법을 궁리하다가 '숫자를 문자로 속여주기'라는 설명의 방법을 찾았다! 바로 key로 사용된 숫자 앞에 '+' 문자를 붙여주는 것. 예를 들어 '20221111'를 '+20221111'로 바꿔주는 것이다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const 전체글 = {
  ['+20221111'] : {
    수필 : ['데자와'],
    정체불명 : ['수성']
  },
  ['+20221110'] : {
    수필 : ['솔의눈'],
    정체불명 : ['금성', '지구']
  },
  ['+20221008'] : {
    수필 : ['제로코크'],
    정체불명 : ['목성', '토성']
  },
  ['+20220909'] : {
    수필 : ['하늘보리']
  },
  ['+20220708'] : {
    정체불명 : ['천왕성', '달']
  }
}
</code>
</pre>
               
          -&gt; 이 방법을 적용시키니 배열을 내가 원하는 순서로 뽑아낼 수 있었다. 즉, for in 반복문이 맨 위에 있는 key부터 접근해줬다. <br> 
          -&gt; 그런데 '속이는 방법' 이라는 점에서.. 왠지 느낌이 좋지 않다. 역시 꼬리가 길면 밟히는 법이라 나중에 이거 때문에 오류가 날 것 같기도 하고.. 뭐 아직 내가 그렇게 복잡한 걸 만들어낼 수 있을 것 같진 않지만. <br>
          -&gt; 우선 '+'를 붙여서 속여주고, 더 나은 방법이 생각나면 바꿔주기로 했다. </p>
          
          <p>자, 이제 만든 배열로 블로그에 기능을 만들어줄 차례다. <br><br> 
          
          코드: 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;javascript&gt;

function RightCategoryList(){
  for(i = 0; i &lt; Categories.length; i++){
    document.write('&lt;a href="' + Categories[i] + '.html"&gt;' + Categories[i] + '&lt;/a&gt;&lt;br&gt;')
  }
}

&lt;css&gt; 

a{
  text-decoration: none;
  color: black;
}
</code>
</pre>
              
          반복문으로 우측 사이드바에 카테고리 이름을 나열해주고 카테고리에 속한 콘텐츠 목록 문서로 연결되는 하이퍼링크를 걸었다. 하이퍼링크가 걸린 텍스트 색이 어울리지 않아서 css로 꾸밈 효과를 빼줬다. 그 결과는, <br><br>
          
          출력:

          <!-- 이미지 -->
          
          이렇게 된다. 링크를 누르면 이동할 페이지의 코드는 이렇게 만들었다. <br><br>
          
          코드: 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function PostList(CategoryName){
  for(i = 0; i &lt; CategoryName.length; i++){
    if(CategoryName[i] !== undefined)
    document.write('&lt;a href='+ CategoryName[i] + '.html&gt;' + CategoryName[i] + '&lt;/a&gt;&lt;br&gt;')
  }
}
</code>
</pre>
          
          출력:

          <!-- 이미지 -->
          
          음료 카테고리에 속한 콘텐츠들이 순서대로 나열됐다. 저 텍스트 링크를 클릭하면 해당 콘텐츠의 문서로 이동되어 콘텐츠를 볼 수 있다! <br><br>
          
          이걸로 콘텐츠를 카테고리별로 분류해 보여주는 기능 구현이 끝났다! <br><br> 
          
          다음으로는 콘텐츠들을 1개월 단위로 묶어서 보여주는 기능을 만들어볼 거다. 실력이 부족해서 사실 여기까지도 시간이 꽤 걸렸는데, 다음 단계는 또 어떻게 될지.. 벌써 걱정이 된다. 하지만 그 또한 그저 묵묵히 걸어가는 것이 코딩 사나이의 길.. 일단 함수 짜는 거나 반복문이나 좀 익숙해지긴 했으니까, 예상한 것보다 더 괜찮게 진행될지도 모르겠다. 아무튼 파이팅..! <br><br>
          
          (중간에 많은 분량이 날아가버려서 복구해내느라 굉장히 힘들었다.)</p>

          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ4&gt; 콘텐츠 1개월 단위로 분류하기</h2>
          
          <p>시간이라는 건 굉장히 굉장한, 그러니까.. 그런 것이다. time files like an allow, 라는 말이 있다. 고등학생이었던 내가 천일문 다 외우면 외국어 영역은 걱정할 것도 없다는 김기훈 쌤의 말을 주어섬긴 채 외운 천일문의 1번 문장이다. 한 300번대까지는 외웠던 것 같다. 근데 2번 문장이 기억이 안 나네.. 다행히 수능은 괜찮게 봤다. <br><br>
          
          다시 돌아와, 내가 종종 방문하는 수필 블로그가 있는데 글을 1개월 단위로 묶어놓은 카테고리가 좋아 보였다. 하루하루는 너무 잘다. 선명하기 어렵다. 그렇다고 3개월 단위로 끊으면 또 너무 덩어리다. 필요 이상으로 뭉개져버린다. 1개월 단위가 딱 이쁘다. 근데 그건 수필 블로그 얘기고,, 이건 또 다르긴 한데,, 음.. 아무튼 그런 것이다. </p>
          
          <p>이번엔 정말로 돌아와, 기간별로 묶어주는 기능도 카테고리 분류와 최종적인 목표물은 같다. 전체 콘텐츠에서 원하는 조건을 만족하는 콘텐츠의  배열을 뽑아내는 것. 문제는 이걸 어떻게 해낼 것이냐인데.. 그러게.. 어떡하지.. <br><br>
          
          작전은 이렇다. 1개월간의 범위를 숫자 형태로 지정하고, 전체글 객체의 key 중 그 범위에 있는 키값을 선택해, 최종적으로 그 콘텐츠의 이름을 배열로 뽑아낸다! 예를 들어 22년 10월에 작성된 콘텐츠들을 모을 거라면, 20221000 &lt; ? &lt; 20221100 범위에 있는 전체글 객체의 key 즉, +20221008를 찾아내는 것이다. 함수를 만들어보자. <br><br>
          
          코드:

          <!-- 이미지 -->
          
          document.write();로 출력해본 결과 2022년 10월 콘텐츠들은 생각대로 뽑혔다. 그런데 2022년 1월 콘텐츠는 아예 출력이 안 됐다. 객체에 <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
['+20220101'] : {
  행성 : ['천왕성', '달']
}
</code>
</pre>
          
          이 있으니까 '천왕성'과 '달'이 출력돼야 하는데.. 뭐가 문제인지 고민.. <br><br>
          
          깨달았다! 기간 범위 지정을 위해 사용한 연.toString() + 월.toString() 부분에서 자릿수가 안 맞았다. 10월의 경우엔 두 자릿수니까 '연'의 숫자와 합치면 6자릿수의 숫자가 나와 문제가 없는데, 1월의 경우엔 한 자릿수라 5자릿수의 숫자가 나와버리는 것이다. 그래서 1을 01로 고쳐봤지만 컴퓨터는 1이든 01이든 그저 1로 인식했다. <br><br>
          
          문제점: <br><br>
          
          '월' 매개 변수에 두 자릿수가 아닌 한 자릿수가 들어가면 의도한 결과를 얻을 수 없다. <br><br>
          
          해결책: <br><br>
          
          한 자릿수가 들어가야 할 경우엔 자동으로 앞에 '0'을 추가해 두 자릿수로 인식하게 하는 함수 제조. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function Plus0(a){
  if(a &lt; 10){
    a = '0' + a
  }
  return a
}
</code>
</pre>
              
          Plus0(); 이라는 이름의 함수를 만들었다. 매개 변수에 10보다 작은 수 즉, 한 자릿수가 놓이면 문자열 '0'을 앞에 추가한 후 리턴해준다. 예를 들어 Plus0(1)의 결과는 '01'이 된다. <br><br>
          
          Plus0(); 함수를 이용해 먼저 만든 함수에서 문제가 된 부분을 수정했다. <br><br>
          
          코드: 

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;한 달 단위로 글 배열 만들기&gt;

function GetByMonth(연, 월){
  let a = (연.toString() + Plus0(월)) * 100;
  let b = (연.toString() + Plus0(월+1)) * 100;
  let c = [];
  for(let key in 전체글){
    if(a &lt; key &amp;&amp; key &lt; b){
      for(i = 0; i &lt; Categories.length; i++){
        c = c.concat(전체글[key][Categories[i]])
      }
    }
  }
  return c
}

document.write('2022년 1월: ' + GetByMonth(2022, 1) + '&lt;br&gt;')
-&gt; 2022년 1월: 천왕성,달
</code>
</pre>
              
          성공! 이제 몇 월이 덤벼와도 배열을 뽑아내는 데 문제가 없다! 일단 여기까지 진행하면서 알게 된 것들을 기록해놓겠다. </p>
          
          <p>1. 문자를 숫자로 연산? <br> 
          -&gt; 내가 함수를 만들어놓고도 도통 이해가 가지 않는 부분이 있다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function GetByMonth(연, 월){
  let a = (연.toString() + Plus0(월)) * 100;
</code>
</pre>
              
          이 부분에서 매개 변수 '연', '월'에는 일단 숫자가 들어가지만, '연.toString()'과 'Plus0(월)'은 분명 문자형(string)이다. 전자는 문자형으로 바꿔주는 .toString(); 메소드를 썼으니 당연히 문자형이고, 후자는 내가 만든 Plus0(a); 함수가 매개 변수로 들어가는 숫자와 문자열 '0'을 결합해주니까 '문자 + 숫자 = 문자' 규칙에 따라 문자형이다. 근데 문자형에 *100을 해줄 수가 있나..? '문자*숫자'가 연산이 되는 게.. 이게 맞아..? 함수를 다시 살펴보다 의문이 들어서 console.log(a);를 찍어봤더니 문제없이 숫자가 출력된다. 이상하다.. <br>
          -&gt; 몇 가지 숫자.toString() 연산을 해봤다. <br><br>
          
          1.toString() + 2.toString() <br>
          // 당연히 연산 자체가 안 된다. '문자 + 문자'니까. <br><br>
          
          (1.toString() + 2.toString())*100 <br>
          // 마찬가지로 연산이 안 된다. <br><br>
          
          -&gt; 음.. 이게 뭘까.. 내가 만든 함수는 분명히 작동하는데.. 혹시나 해서 숫자를 변수로 대체해봤다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
x = 1;
y = 2;
x.toString() + y.toString() = '12'
// 어..? 된다. 다만 '문자 + 문자'라서 횡으로 결합됐다. 즉, '12'라는 문자열(string)이다.  
</code>
</pre>
         
          -&gt; 내가 만든 함수처럼 여기다 100을 곱해봤다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
x = 1;
y = 2;
(x.toString() + y.toString())*100 = 1200
// 문자('12')에 100을 곱했더니 숫자(1200)이 나왔다.
</code>
</pre>
              
          -&gt; 이걸로 내 함수가 제대로 작동한 이유가 밝혀졌다. 그런데.. 이게 왜 갑자기 숫자형으로 변했는지는 모르겠다.. 아니 분명 문자에 숫자를 곱했는데.. 혹시나 해서 typeof()를 찍어봤더니 분명 'number'다. 'NaN'이 아니라.. <br><br>
          
          검색어: javascript 문자 곱하기 숫자 <br><br>
          
          <!-- 이미지 -->
                   
          출처: https://spiritfestival.tistory.com/48 <br><br>
          
          -&gt; 곱하기 연산자는 '문자*숫자' 연산 시 문자열이 숫자로 되어 있으면 문자열을 숫자로 변환해 연산한다고 한다. 그 이유는 곱하기 연산이 문자열에 대해 정의가 안 되어 있기 때문이라는데, 간단히 하면 '원래 그렇기 때문'이다. 더불어 빼기와 나누기에 대해서도 마찬가지. 그러니 흡사 종교의 교리처럼 '숫자로된 문자열에 숫자를 곱하면 숫자형이 된다'라고 알아두면 될 것 같다. <br>
          -&gt; 나는 '원래 그렇다'를 근거로 드는 걸 되게 싫어하긴 하지만, 이 경우엔 여기서 멈춰 끄덕이는 게 좋지 않을까 싶다. 여기서 원리를 더 파다가는 힘들어질 것 같으니까. 아마 현재 수준에선 이해하기조차 어려운 이유들일 것이다. <br>
          -&gt; 아무튼 이제야 의문이 풀려서 속이 다 시원하다. 읽고 있는 책에서 javascript는 상대적으로 유연한 언어라고 했었는데, 아마 이런 부분을 말하는 게 아닐까 싶다. 정말 그런지는 좀 더 실력이 쌓여야 확실해지겠지만. </p>
          
          <p>2. &amp;&amp; <br><br>

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
if(a &lt; key &amp;&amp; key &lt; b)  
</code>
</pre>
          
          -&gt; 이 식은 찾는 key의 범위를 정해준다. 22년 11월의 콘텐츠를 찾는다면, '20221100 &lt; key &amp;&amp; key &lt; 20221200' 이렇게. <br><br>
          -&gt; 처음에는 '&amp;&amp;'를 쓰지 않고 'a &lt; key &lt; b'라고 썼다. 수학 문제를 풀 때 사용했던 것처럼. 그런데 엉뚱깽뚱한 결과가 나왔다. 몇 번을 고민해봐도 식은 맞았다. 결과를 받아들일 수 없었지만, 내 생각에 완벽한 외국어를 구사했다 쳐도 네이티브가 알아듣지 못한다면 문제는 내 쪽에 있는 법이다. <br><br>
          -&gt; 'a &lt; key &lt; b'를 'a &lt; key', 'key &lt; b' 두 개로 쪼개고 '&amp;&amp;'로 엮었다. 결과는.. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
GetByMonth(2022, 1)

&amp;&amp;_X(a &lt; key &lt; b)
// 데자와,수성,솔의눈,금성,지구,제로코크,목성,토성,하늘보리,천왕성,달

&amp;&amp;_O(a &lt; key &amp;&amp; key &lt; b)
// 천왕성, 달
</code>
</pre>
          
          성공! 같은 의미인 것 같은데 결과가 왜 달라졌는지 알아봤다. </p>
          
          <p>검색어: javascript &amp;&amp; <br><br>
          
          -&gt; 컴퓨터는 좌(left)에서 우(right)로 코드 평가를 진행한다(고 한다). 그리고 위에서 예를 든 조건문과 같은 경우, 먼저 평가한 좌항('a &lt; key')이 true로 평가되면 거기서 평가를 멈춰버린다. 즉, 뒤에 나오는 우항('key &lt; b')의 평가값과는 상관없이 if(true)의 프로세스를 진행시켜버리는 것이다. 정확히 말하면 좌항이 true라면 우항은 평가를 진행하지도 않는다. 거기서 멈춰버리니까. 이것을 '단축 평가'라고 한다. <br>
          -&gt; &amp;&amp; 연산자는 이 단축 평가를 막는다. 좌항과 우항을 모두 살피게 한다. 둘 다 true로 평가하고 나서야 다음 프로세스를 진행시킨다. <br><br>
          
          기본적으로 수학이지만 완전히 수학은 아니다. 내가 원하는 걸 특정한 규칙의 언어로 컴퓨터에게 전달해야 한다. 음.. 맞나..? 사실 아직 잘 모르고 하는 얘기다. 아무튼 그런 느낌이 든다. 같지만 완전히 같진 않다는. <br><br>
           
          이번엔 실수가 아니었다. 애초에 몰랐으니까. 그리고 이젠 알게 됐다. 다음부터는 실수가 되는 것이다. 공부한 건 기억해두자. 나름 애써서 배운 거니까. 그리고, 시간이 많지 않으니까. 아직 여유가 있는 사람들처럼 부족함을 시간으로 만회할 기회는 별로 주어지지 않을 거다. 나는 꽤나 시급하다. <br><br>
          
          작성일 기준 1개월 단위로 콘텐츠를 모아내는 함수까지 만들었다. 이제 우측 사이드바에 콘텐츠가 담겨 있는 각 연월을 목록화해줄 차레다. 물론 자동으로 목록이 만들어질 수 있게. 콘텐츠가 없는 연월도 자동으로 거른 채로. </p>
          
          <p>목록이 '2022년 11월', '2022년 8월' 이런 형식으로 보여지게 하고 싶었다. 날짜를 나타내는 key가 '+20221010' 이런 식이니까 여기서 숫자를 적절히 잘라서 사용하면 될 것 같았다. 문자열의 특정 부분만 잘라내는 기능을 검색했다. <br><br> 
          
          검색어: javascript 문자열 자르기 <br><br>
          
          substr(시작 위치, 길이); <br>
          -&gt; 문자열을 '시작 위치'부터 '길이'만큼 자른다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
'일이삼사오육'.substr(1, 2) = '이삼' 
</code>
</pre>
          
          -&gt; '시작 위치'는 필수, '길이'는 생략할 수 있다. '길이' 부분이 없으면 '시작 위치'부터 끝까지 자른다. <br><br> 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
'자바스크립트'.substr(1) = '이삼사오육'
</code>
</pre>
          
          -&gt; 주의: 위치는 문자열의 index값이다! 즉, 0부터 시작한다! <br><br>
          
          substring(시작 위치index, 종료 위치) <br>
          -&gt; 문자열을 '시작 위치'부터 '종료 위치'까지 자른다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
'일이삼사오육'.substring(1, 3) = '이삼'
</code>
</pre>
          
          -&gt; '시작 위치'는 필수, '종료 위치'는 생략할 수 있다. '종료 위치' 부분이 없으면 '시작 위치'부터 끝까지 자른다. <br>
          -&gt; 주의할 점은 인덱스상 '종료 위치의 -1'까지 자름! <br>
          -&gt; '시작 위치' 자리에 음수를 넣으면 '0'으로 대체된다. '종료 위치' 자리에 음수를 넣으면 인자의 순서가 뒤바뀐다. 근데 인자에 음수를 넣을 일이 있나..? <br><br>
          
          slice(시작 위치index, 종료 위치) <br><br>
          
          -&gt; substring();과 비슷하다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
'일이삼사오육'.slice(1, 3) = '이삼'
</code>
</pre>
              
          -&gt; '시작 위치'에 음수가 오면 문자열을 뒤에서부터 자른다. 즉 시작 위치의 인수가 '-a'라고 하면 뒤에서부터 a자리 숫자부터 자르는 것. 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
'일이삼사오육'.slice(-2) = '오육'
</code>
</pre>
              
          나는 문자열을 가르는 검으로 stbstr();를 사용하기로 했다. 왜냐면! 가장 쉬워 보여서! </p>
          
          <p>우선 key를 이렇게 저렇게 자르는 함수를 만들었다. <br><br>
          
          코드: 

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function Slicer(x, y, z){
  return x.substr(y, z)
}
</code>
</pre>
              
          만약 '+20221230'이라는 key에서 연도 부분만 잘라내 사용하고 싶다면 <br><br> 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
Slicer(key, 1, 4) = '2022'
</code>
</pre>
                  
          이런 식으로 쓴다. <br><br>
          
          자 이제 key를 가지고 목록을 만들어주는 함수를 짜보자! 이것도 최종 목표는 배열이다. 콘텐츠가 들어 있는 날짜 즉, key를 선택해내고, 그걸 가공해 반복문으로 출력하는 데 쓰일 적확한 배열을 만들어내야 한다. 목록의 형식은 '2022년 7월' 이런 식으로 만들어줄 생각이다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;우측 사이드바 1개월 단위 목록 만들기&gt;

function RightMonthList(){
  let a = [];
  for(let key in 전체글){
    //-&gt; for in문을 사용해 특정한 형태로 가공될 key를 전달해줄 것. 
    if(Slicer(key, 5, 2) &lt; 10){
      //-&gt; '월'이 한 자릿수인 key를 따로 분류. key에서 잘라줄 부분의 범위가 다르니까.
      let b = Slicer(key, 1, 4) + '년 ' + Slicer(key, 6, 1) + '월';
      //-&gt; 7월이 07월처럼 어색하게 표시되지 않게 하려고 6index만 잘라 쓴다.
      a = a.concat(b);
    }
    else{
      //-&gt; '월'이 두 자릿수인 key는 이쪽으로 분류된다.
      let c = Slicer(key, 1, 4) + '년 ' + Slicer(key, 5, 2) + '월';
      //-&gt; '월' 첫 번째 자리에 '0'이 붙을 일이 없으니 5index부터 2길이만큼 잘라 쓴다. 
      a = a.concat(c);
    }
  }
  let d = [...new Set(a)];
  //-&gt; concat();으로 축적 &amp; 변화된 배열 a 중 중복된 요소를 제거해준다. key에 3월이 두 개라서 '2022년 3월'이라는 요소가 배열에 두 번 포함되어버리니까. 
  for(i = 0; i &lt; d.length; i++){
    document.write('&lt;a href="' + d[i] + '.html"&gt;' + d[i] + '&lt;/a&gt;&lt;br&gt;');
    //-&gt; 해당 목록의 html 문서 링크를 걸어서 보기 좋게 출력.
  }
}

RightMonthList()
</code>
</pre>
             
          처음엔 '월'의 자릿수에 따라 공정을 분리하지 않았다. 복잡해질까 봐. 그치만 '2022년 03월' 같은 텍스트가 좀 어색해서 '월'이 한 자릿수인 key와 두 자릿수인 key의 공정을 나눴다. 두 공정의 차이점은 전자에 대해선 '월'을 나타내기 위해 index6의 숫자만 취했고, 후자는 index5부터 두 자리의 숫자 모두를 취했다. 훨씬 보기 좋아져서 뿌듯하다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
let d = [...new Set(a)];
</code>
</pre>
              
          이 부분이 위기였다. 3월에 해당하는 key가 두 개기 때문에 반복 과정에서 각각 한 번씩 concat(); 되어 배열 a에 '2022년 3월'이라는 요소가 두 번 등장했다. 함수를 짤 때 고려하지 못했던 문제였다. 내겐 중복된 요소를 제거하는 기술이 없었다. 그렇다면? </p>
          
          <p>검색어: javascript 배열 중복 제거 <br><br>
          
          1. new Set(a); <br>
          -&gt; Set 객체는 중복되지 않는 값들의 집합이(라고 한)다. <br>
          -&gt; 중복된 요소가 포함된 배열 a를 Set 객체로 만들어 중복을 제거한다. <br>
          -&gt; 이렇게 생성된 Set 객체는 '유사 객체'라고 한다는데.. 사실 아직까진 잘 이해가 가지 않는다ㅠㅠ. 포스팅들을 읽어보니 '객체긴 객첸데 배열의 성격이 강한 객체' 정도로 일단 생각하면 될 것 같다. 나중에 요놈에 대해 더 공부해보고 정확한 이해를 성공해내면 설명을 추가하러 다시 돌아오겠다! <br><br>
          
          2. [...a](전개연산자) <br>
          -&gt; a가 배열(혹은 유사 객체)일 때 그 요소들을 늘어놓아 배열로 만든다.. 라고 일단 이해했다. 정확히 이해한 건지는.. 지금은 확신할 수 없다ㅠㅠ. <br>
          -&gt; 일반적인 객체에 대해서는 적용되지 않는 것 같다.

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
[...전체글];
</code>
</pre>
              
          이렇게 쓰면 오류가 나는 걸 보면.

          <pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
[...'전체글'];
</code>
</pre>
                    
          이렇게 쓰면 ['전', '체', '글']이라는 배열이 된다. 어.. 근데 typeof를 찍어보니까 object라고 나오네..? 어.. <br><br>
          
          솔직히 지금 상황에선 new Set(a);나 [...(a)];에 대한 이해가 부족하다. 확실히 알아보려고 좀 찾아봤는데 대략적으로는 알 것 같으면서도 또 설명하라고 하면 이게 잘 안 된다ㅠㅠ.. <br><br>
          
          일단 함수는 잘 작동하니까, 일단 나중에 꼭 돌아와 정확한 설명을 써내고 말겠다는 다짐을 해두고 다음 단계로 전진하겠다! <br><br>
          
          이제 제조한 함수들을 페이지에 적용한다. 사이드바에 1개월 단위 콘텐츠 묶음 링크를 목록화 하고, 그 링크로 연결되는 페이지에 해당 콘텐츠들을 목록화할 생각이다. 우선은 사이드바부터. <br><br>
          
          코드: 
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
RightMonthList();
</code>
</pre>
              
          결과:
          
          <!-- 이미지 -->

          다음은 월별 목록 링크를 클릭하면 나오는 화면을 작업해준다. <br><br>
          
          결과:
          
          <!-- 이미지 -->

          </p>
          
          <p>이걸로 블로그의 기본적이고 꼭 필요한 기능의 구현은 끝났다. 다음 단계에서는 현재 수준에서 자동화할 수 있는 건 최대한 자동화해보려고 한다. 작성일이라든가 제목 출력이라든가. <br><br>
          
          아직 대단한 뭔가를 해낸 건 아니다. 그건 내가 봐도 자명하다. 그치만 내가 머릿속에 떠올렸던 것들이 조금씩 실체화되어간다는 실감은 확실히 좋은 기분을 불러온다. 중요한 건 기분이다. 경쾌함을 불러오는 기분. 물론 가장 중요한 건 아니겠지만, 그래도 신이 난다. 지속력을 가져다준다. 그리고, 자꾸 희망을 꾸려보게 만든다. 발을 내딛어보기 전까지는 감히 상상하기도 어려웠던 희망을. 인간의 상상력은 쉽게 뻗어나간다. 단, 현재 해낼 수 있는, 지금의 능력으로 가능하단 판단이 드는 곳까지만. 그 너머로 마저 뻗어내는 일은 결코 거저 되어지는 일이 아니다. 그것이 거인의 어깨에 올라보려는 이유일 것이다. 속성으로라도. <br><br>
          
          너머까지도, 파이팅. </p>
          
          <br><hr><br>

          <h2>&lt;ㅇ.ㅇ5&gt; 지난 결과물들에 대한 점검과 디테일의 자동화</h2>
          
          <p>그동안 제조한 코드들을 쭉 다시 살펴봤다. html과 css는 화면과 1:1 대응이다. 덜어내거나 수정할 부분이 크게 보이지 않았다. <br><br>
          
          script 문서의 코드들에선 개선의 여지가 보였다. 내가 만든 javascript 코드는 크게 두 가지 부류였다. 첫 번째는 필요한 배열을 제조하는 함수, 그리고 두 번째는 필요한 배열을 제조한 후에 목록으로 출력해주는 함수. 코드들을 쭉 살피며 생각해보니 두 번째 함수에 대해 굳이 '배열 제조'와 '목록으로 출력' 기능을 결합시켜놓을 필요가 있나? 라는 의문이 들었다. 배열을 만드는 함수는 그 배열이 필요한 상황에서 간단히 재사용할 수 있겠지만, 배열 제조와 출력 기능이 같이 들어가 있으면 그걸 다시 써먹을 데가 아무래도 한정적이니까. <br><br>
          
          리스트화해서 출력하는 과정은 비슷했다. 배열을 반복문으로 풀어서 배열의 요소 하나하나에 링크를 걸어 세로로 쌓는다. 즉, <br><br>

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function PostList(CategoryName){
  for(i = 0; i &lt; CategoryName.length; i++){
    if(CategoryName[i] !== undefined)
    document.write('&lt;a href='+ CategoryName[i] + '.html&gt;' + CategoryName[i] + '&lt;/a&gt;&lt;br&gt;')
  }
</code>
</pre>
              
          대체로 이런 식이었다. 그래서 배열만 얹어주면 목록으로 만들어주는 '출력 전용 함수'를 만들기로 했다. 목록화가 필요하면 그때그때 배열 제조 함수를 얹어주기만 하면 되는 식으로. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function MakeList(Array){
  for(i = 0; i &lt; Array.length; i++){
    document.write('&lt;a href='+ Array[i] + '.html&gt;' + Array[i] + '&lt;/a&gt;&lt;br&gt;')
  }
}
</code>
</pre>
              
          배열을 제조와 document.write();가 합쳐져 있던 함수에서 화면 출력 부분을 삭제하고 배열 제조 기능만 남겼다. 앞서 만든 MakeList(); 함수를 활용해 배열을 받아와 목록으로 출력하는 함수들을 만들었다. 이 함수들을 어떻게 정리할까 고민하다가, 함수들이 사용되는 @위치에 따라 분류했다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;@본문_카테고리별 콘텐츠 목록화 함수&gt;

function Main_List_PostsByCategoryName(CategoryName){
  MakeList(Array_GetByCategory(CategoryName));
};

// &lt;@본문_연월별 콘텐츠 목록화 함수&gt;

function Main_List_PostsByYearMonth(연, 월){
  MakeList(Array_GetByYearMonth(연, 월));
};

// &lt;@사이드바_모든 글 목록화 함수&gt;

function Sidebar_List_AllPosts(){
  document.write('&lt;a href="모든 글.html"&gt;모든 글&lt;/a&gt;&lt;/style&gt;&lt;br&gt;')
};

// &lt;@사이드바_카테고리 목록화 함수&gt;

function Sidebar_List_Category(){
  MakeList(Categories);
};

// &lt;@사이드바_연월 목록화 함수&gt;

function Sidebar_List_YearMonth(){
  MakeList(Array_YearMonthList());
};
</code>
</pre>
</p>
                
          <p>나름 리팩토링을 해보자! 하고 시작한 거긴 한데.. 이렇게 하는 게 맞나 싶다. 내 생각엔 편의성 면에서는 전보다 나아졌다. 출력용 함수만 따로 모으고 그걸 사용되는 위치에 따라 다시 정리해놓은 게 좋은 생각이었던 것 같다. 기능적으로는 모르겠지만, 페이지의 어떤 부분이 이상할 때 스크립트 문서의 어디를 봐야 하는지 감이 쉽게 잡힌다. <br><br>
          
          근데 이런 간단한 스크립트 문서도 계속 이렇게나 길어지는데, 언젠가 현업에서 일을 하게 되면 얼마나 길고 복잡한 코드를 다뤄내야 하는 걸까? 벌써부터 걱정이 된다. <br><br>
          
          후.. 잘해낼 수 있겠지? 다음에는 왠지 자동화될 수 있을 것 같단 예감이 드는.. 그런 자잘한 부분들을 고민해보고 기능을 만들어보려고 한다. 잘하자~~ 웅비~~! <br><br>
          
          끝으로 오늘 정리한 script 코드를 적어놓는다. 브라우저에선 오류가 없는데 코드펜에선 계속 함수 정의가 안 됐다고 나온다.. 문제없는 것 같은데.. 왜 이러는지 모르겠다. <br><br>
          
          코드:
          
          <!-- 코드펜 -->
 
          </p>
          <br><hr><br>

          <h2>&lt;ㅇ.ㅇ6&gt; index 페이지 리디렉션</h2>
          
          <p>블로그 첫 페이지에서 뭘 보여주면 좋을지 생각해봤다. 각종 카테고리의 글 목록이나.. 가장 마음에 드는 콘텐츠.. 혹시 내 사진과 프로필을 적어놓으면 평생을 함께할 반려자를 만나게 될 수도 있지 않을까..? 쓸데없고 긴 고민 끝에, 가장 최근 글을 띄우기로 했다. 조회수 사냥꾼 블로그도 아니고 아직까진 듀오에 가입해야 할 처지도 아니니, 그냥 내가 좋을 대로 하면 되는 것이다. 게다가 사실 내 사진을 걸어놓는다면, 이런 녀석이 만든 블로그는 볼 것도 없을 거야 흥! 하며 휙 나가버릴 가능성이 크다. <br><br>
          
          * index.html <br><br>
          
          index.html이란 건 뭘까..? 나도 일단 만들어놓긴 했다만, 딱히 이것의 정체에 대해서 생각해본 적은 없었다. 생활코딩 강의를 들을 때 첫 페이지를 index.html로 만들길래 어.. 이게 대문인가? 하고 나도 그냥 따라 만들었다. 빌어먹을 논산 훈련소에서 줄 지어 걷다가 분대장이 왼발! 왼발! 구령을 넣으면 어라.. 왜 왼발만 외치지? 오른발은? 저 자식 좌파인가? 라고 의심하지 않듯이, index.html에 대해서도 그냥 그런가 보다 하고 받아들인 것이다. <br><br>
          
          하지만 이런 무비판적 태도는 바람직하지 않다. 개인적인 얘기지만 나는 대학생 시절 철학을 전공했는데, 엄청나게 두꺼운 책을 쓴 철학사의 거인들께선 하나같이 모든 걸 의심해야 한다고 열변하셨다. 심지어 사람들이 그것을 진리라고 부를지라도! 무엇을 그냥 당연하다는 이유로 당연하게 받아들여서버려서는 안 된다는 것이다. 모피어스를 만나기 전의 네오마냥 사람들이 말하는 당위를 흡사 스펀지가 되어 흥청망청 수용해대며 살던 나는, 철학을 만나 비판적 사고의 화신이 되었고 모든 것을 의심했다. 이 세상은 사실 매트릭스가 아닐까.. 지구는 둥글다는 건 고정관념이 아닐까.. 천부인권이란 그저 인간의 편의에서 잉태된 게 아닐까.. 어느 교양 강의의 중간 고사 문제는 생명은 왜 소중한지 서술하시오, 였다. 나는 답안지에 생명은 소중하다는 당위 이면에 도사리는 인간의 탐욕들을 낱낱이 밝혀내었다. 학기 말에 A학점을 거머쥔 나는 이 철학의 기본 태도에 더욱 확신을 갖게 되었고,, <br><br>
          
          현재 직업도 없이 방구석에서 이러고 있다.. 철학이란 꽤 위험한 학문일지도 모르겠다. <br><br>
          
          아무튼, 이번 기회에 index.html에 대해 알아보기로 했다. </p>
          
          <p>검색어: index.html <br><br>
          
          -&gt; index.html은 첫 페이지로 통용된다. <br>
          -&gt; 역사가 깊은 이것은 이미 표준이 되어 웹 페이지를 작동시키는 프로그램들도 index 문서를 첫 페이지, 대표 페이지로 인식한다. <br><br>
          
          그러니까, 블로그의 첫 페이지를 꾸미려면 index.html을 손봐야 하는 것이다. <br><br>
          
          앞서 말했듯 나는 첫 페이지에서 가장 최근 게시물 하나를 보여주고 싶었다. 어떻게 해야 할까 고민하다 내 블로그 주소로 접속을 하면 묻지도 따지지도 않고 곧바로 최근 게시물.html 문서로 보내주면 되겠다 싶었다. 검색에 들어갔다. <br><br>
          
          검색어: javascript 다른 페이지로 이동시키기 <br><br>
          
          1. window.location.replace('url'); <br>
          -&gt; 해당 url 페이지로 이동시킨다. <br>
          -&gt; 페이지에 덮어 씌우는 방식으로 히스토리가 기록되지 않는다. 뒤로가기를 해도 변경 전의 페이지에 다시 도달할 수 없다. 변경 전 페이지에 머무를 이유가 없거나 공개되어선 안 될 페이지에 활용한다. <br>
          -&gt; window 객체의 메서드. <br><br>
          
          2. window.location.href = "url"; <br>
          -&gt; 해당 url 페이지로 이동시킨다. <br>
          -&gt; 현재 페이지에 도착한 뒤 새로운 페이지로 이동시켜주는 방식으로 히스토리에 기록된다. 뒤로가기를 누르면 이전 페이지로 이동한다. <br>
          -&gt; 프로퍼티의 속성. <br><br>
          
          replace('url');을 사용하기로 했다. 사실 어느 때는 뭘 써야 되는지 확신이 서진 않는데, 일단은 접속자가 index 페이지에 머물러야 할 이유가 없으니까. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
- js

const 모든글 = Array_GetAllPosts();

- html

  &lt;body&gt;
    &lt;script&gt;
      window.location.replace(모든글[0] + '.html');
    &lt;/script&gt;
  &lt;/body&gt;
</code>
</pre>
              
          작성일 기준으로 전체 콘텐츠를 배열로 만드는 함수를 사용해서 '모든글' 변수에 담았다. 그리고 index.html 문서의 &lt;body&gt; 태그 안에 '모든글' 변수에 담긴 배열의 첫 번째(index 0) 요소 즉, 가장 최신글 문서로 이동시켜주는 코드를 삽입했다. 이제 내 블로그의 첫 번째 페이지에선 최신 콘텐츠 한 편이 출력된다! <br><br>
          
          이어서 블로그 이름에도 텔레포트 기능을 추가해주기로 했다. 가장 상단의 블로그 이름을 클릭하면 index.html과 동일하게 최신 콘텐츠 페이지로 이동시키는 것이다. 기존 코드는 이렇다. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;p id = "BlogName"&gt;zo0ozzz&lt;/p&gt;
</code>
</pre>
                
          이 기능의 구현에 대해 두 가지 방법을 생각해봤다. <br><br>
          
          1. a태그로 클릭 시 index.html로 이동시킨다. <br>
          -&gt; index.html에 window.location.replace();가 걸려 있으니 결과적으로 최신 콘텐츠 페이지로 이동한다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;p id = "BlogName"&gt;&lt;a href = "index.html" style = "text-decoration: none"&gt;zo0ozzz&lt;/a&gt;&lt;/p&gt;
</code>
</pre>
                    
          -&gt; 기존 p태그를 지우고 id도 a태그로 옮겼으면 조금 더 깔끔해졌을 텐데, 이름 위치 조정을 p태그로 해서 a태그로 변경하면 틀어졌다. 그래서 기존 p태그에 a태그를 붙여줬다. <br>
          -&gt; 마우스 호버 상태에서 생기는 밑줄을 없애려고 style = "text-decoration: none"을 추가해줬다. <br><br>
          
          기능이 잘 작동한다. 하긴 그냥 다른 문서로 넘어가는 하이퍼링크를 걸어준 것뿐이니까 문제가 생길 일도 없다. 다만 없애도 되는 p태그를 살려뒀고 코드가 조금 길어진 게 아쉽다. <br><br>
          
          2. onclick으로 클릭 시 최신 콘텐츠 페이지로 이동시킨다. <br>
          -&gt; 기존의 p태그에 onclick="HomeButton();"를 추가해준다. 팀버튼이 아니라 홈버튼이다. 팀버튼 홈버튼. ㅋㅋㅋ 웃기다. 나만 웃길까..? <br>
          -&gt; HomeButton(); 함수는 스크립트 페이지에 만들어준다. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function HomeButton(){
  window.location.href(모든글[0] + '.html');
}

</code>
</pre>
          
          -&gt; replace로 덮어버리면 뒤로가기를 눌렀을 때 이동하기 전 머물던 페이지로 못 돌아오기 떄문에 href를 써줬다. <br>
          -&gt; js가 가능해져서 index.html으로 두 번 환승하는 것보단 최신 콘텐츠로 바로 가는 게 낫다고 판단, 그 페이지 링크를 걸어줬다. <br><br>
          
          두 방법을 다 해보고선 첫 번째 방법을 사용하기로 했다. 왜냐면 두 번째 방법으로 기능을 구현하면 블로그 이름에 마우스를 갖다 댔을 때 커서가 손가락 모양으로 안 변했다ㅠㅠ. 그러고 보니 onclick을 사용할 땐 항상 클릭 버튼을 달아줬었다. 커서 모양이 안 바뀌니 이 버튼을 누르면 뭔가 이벤트가 일어난다고 시각적으로 알려줘야 하는 것이다. 그래서 버튼을 달아봤는데, <br><br>
          
          <!-- 이미지 -->
          
          귀엽긴 했지만,, 블로그 이름씩이나 되는 포지션에 어울리진 않았다. 위엄이 부족하다고 할까. 위엄이라는 건 귀여움에 비할 바가 아니지만, 어떤 맥락 속에서는 또 귀여움보다는 위엄이 필요할 때가 있는 것이다. 예를 들어 대통령이 귀엽기만 하다면.. 국정 운영에 어려움이 좀 있지 않을까..? 그쪽 세계에서는 귀엽다고 뭔가를 양보해주는 일은 없을 테니까. 그냥 그런 생각이 든다. 진짜 쓸데없네.. </p>
          
          </p>다음은 가장 어려울 것으로 예상되는 일이다. 바로,, 사이드바의 항목들 옆에 속해 있는 콘텐츠의 개수를 출력해주는 기능! 예를 들면 이렇다. <br><br>
          
          음료(6) <br><br>
          
          어떻게 해야 할까.. 고민해본다. 그렇게 시간이 지나고.. 또 지나고.. <br><br>
          
          배열 제조 함수가 있으니까 .length(); 메서드를 적절히 사용하면 될 것 같다. <br><br>
          
          '모든 글'과 '카테고리별' 목록에 (콘텐츠 개수)를 추가해줬다. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;@사이드바_모든 글 목록화 함수&gt;

function Sidebar_List_AllPosts(){
  document.write('&lt;a href="모든 글.html"&gt;모든 글&lt;/a&gt;' + '&lt;span style = "font-size: 11px"&gt; (' + Array_GetAllPosts().length + ')&lt;/span&gt;&lt;br&gt;')
};

// &lt;@사이드바_카테고리 목록화 함수&gt;

function Sidebar_List_Category(){
  let a = [];
  for(i = 0; i &lt; Categories.length; i++){
    document.write('&lt;a href = "' + Categories[i] + '.html"&gt;' + Categories[i] + '&lt;/a&gt;' + '&lt;span style = "font-size: 11px"&gt; (' + Array_GetByCategory(Categories[i]).length + ')&lt;/span&gt;&lt;br&gt;');
  }
}
</code>
</pre>
              
          -&gt; '모든 글'과 '카테고리별' 목록에 (콘텐츠 개수)를 추가하는 건 간단했다. 정확히 말하자면 이후에 나올 '연월별' 목록에 (콘텐츠 개수)를 추가하는 것보다는 '비교적' 간단했다. <br>
          -&gt; 생각한 대로 배열 제조 함수를 이미 갖고 있었기 때문에 거기에 .length(); 정도를 추가해주면 됐다. <br>
          -&gt; &lt;a href&gt;로 링크를 걸어주는 일도, 연결해줄 문서와 링크가 걸리는 텍스트가 동일하기 떄문에 그렇게 어렵진 않았다. 그러니까 '음료'라는 텍스트에 걸리는 링크가 '음료.html'인 것이다. '원월별' 목록화 함수는 저 둘이 다르다. 이건 잠시 뒤에 설명하겠다. <br>
          -&gt; 해놓고 보니 시각적으로 별로 안 예뻐서 &lt;span&gt;&lt;style&gt;을 사용해 좀 꾸며줬다. </p>
          
          <p>이번엔 '연월별' 목록에 (콘텐츠 갯수) 항목을 삽입하려 했다. 나는 앞전의 성공으로 자신만만하게 덤벼들었지만,, 쉽지 않은 과정이었다. 일단 코드만 보면 메커니즘은 비슷하다. <br><br> 
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
  function Sidebar_List_YearMonth(){
    let a = [];
    for(let key in 전체글){
      //-&gt; for in문을 사용해 특정한 형태로 가공될 key를 전달해줄 것.
      if(Slicer(key, 5, 2) &lt; 10){
        //-&gt; '월'이 한 자릿수인 key를 따로 분류. key에서 잘라줄 부분의 범위가 다르니까.
        let b = '&lt;a href = "' + Slicer(key, 1, 4) + '년 ' + Slicer(key, 6, 1) + '월.html"&gt;' + Slicer(key, 1, 4) + '년 ' + Slicer(key, 6, 1) + '월&lt;/a&gt;' + '&lt;span style = "font-size: 10px"&gt; (' + Array_GetByYearMonth(Slicer(key, 1, 4), Slicer(key, 6, 1)).length + ')&lt;/span&gt;&lt;br&gt;';
        //-&gt; 7월이 07월처럼 어색하게 표시되지 않게 하려고 6index만 잘라 쓴다.
        a = a.concat(b);
      }
      else{
        //-&gt; '월'이 두 자릿수인 key는 이쪽으로 분류된다.
        let c = '&lt;a href = "' + Slicer(key, 1, 4) + '년 ' + Slicer(key, 5, 2) + '월.html"&gt;' + Slicer(key, 1, 4) + '년 ' + Slicer(key, 5, 2) + '월&lt;/a&gt;' + '&lt;span style = "font-size: 10px"&gt; (' + Array_GetByYearMonth(Slicer(key, 1, 4), Slicer(key, 5, 2)).length + ')&lt;/span&gt;&lt;br&gt;';
        //-&gt; '월' 첫 번째 자리에 '0'이 붙을 일이 없으니 5index부터 2길이만큼 잘라 쓴다.
        a = a.concat(c);
      }
    }
    let d = [...new Set(a)];
    //-&gt; concat();으로 축적 &amp; 변화된 배열 a 중 중복된 요소를 제거해준다. key에 3월이 두 개라서 '2022년 3월'이라는 요소가 배열에 두 번 포함되어버리니까.
    for(i = 0; i &lt; d.length; i++){
      document.write(d[i]);
    }
  };
</code>
</pre>
              
          -&gt; 앞서 만들어뒀던 Sidebar_List_YearMonth(); 함수를 개량했다. 문제는 괄호에 들어갈 콘텐츠 개수가 도저히 내 생각대로 나와주질 않는다는 것이었다. 내가 한 설계에서는 '2022년 3월 (4)' 이렇게 출력이 되어야 했는데 '2022년 3월 (9)' 이렇게 엉뚱한 숫자가 찍혔다. '연월' 부분은 맞지만 '괄호 안의 숫자'가 완전히 틀렸다. 대체 어떻게 된 것일까.. <br>
          -&gt;  저 함수에서는 '글전체' 객체의 key가 반복문으로 돌아간다. 만약 key가 '+20220303'이라면 함수에 사용된 'Slicer(key, 1, 4)'와 'Slicer(key, 6, 1)'은 분명 '2022', '3'이 나온다. 이 숫자는 해당 연월의 콘텐츠 배열을 만드는 Array_GetByYearMonth(Slicer(key, 1, 4), Slicer(key, 6, 1)); 함수에도 그대로 들어가, 결과적으로 Array_GetByYearMonth(2022, 3).length 값이 '4'가 나와야 한다. 2022년 3월의 콘텐츠가 ['제로코크', '목성', '토성', '하늘보리'] 이렇게 4개니까. 근데 이 값이 죽었다 깨나도 '9'로 나왔다. 뭔 짓을 해봐도 9였다. 이거야 귀신이 곡할 노릇이었다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
console.log(Slicer(key, 1, 4), Slicer(key, 6, 1), Array_GetByYearMonth(Slicer(key, 1, 4), Slicer(key, 6, 1)).length)
</code>
</pre>
              
          결과:
          
          <!-- 이미지 -->
          
          다른 key가 돌아갔을 때도 마찬가지였다. <br><br>
          
          결과: <br><br>
          
          2022년 12월 (2) <br>
          2022년 10월 (5) <br>
          2022년 3월 (9) <br>
          2022년 1월 (9) <br><br>
          
          원래 올바른 값은 이렇다. <br><br>
          
          2022년 12월 (2) <br>
          2022년 10월 (3) <br>
          2022년 3월 (4) <br>
          2022년 1월 (2) <br><br>
          
          나는 이 문제로 고민에 고민을 거듭하다 머리가 아파서 침대에 잠깐 누웠다. 그리고 눈을 감고 열심히 또 열심히 머리를 굴려댄 결과..! <br><br>
          
          잠들고 말았다. 달콤한 꿈을 꿨다. <br><br>
          
          깨어나니 다음 날이었다. 한껏 맑아진 머리로 다시 함수를 째려봤다. 계속 말도 안 되는 숫자만 뱉어내는 함수를 부정하다가 함수에게 화도 내보다가 제발 되라며 빌어도 보다가 결국 인정하게 됐다. 나의 설계에 뭔가 문제가 있다. 찾아내자. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
console.log(Slicer(key, 1, 4), Slicer(key, 6, 1), Array_GetByYearMonth(2022, 3), Array_GetByYearMonth(Slicer(key, 1, 4),  Slicer(key, 6, 1)))
</code>
</pre>
              
          결과:
          
          <!-- 이미지 -->
          
          Array_GetByYearMonth(2022, 3);의 결과는 분명 이것이다. <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
['제로코크', '목성', '토성', '하늘보리']
</code>
</pre>
              
          하지만 Slicer(key, 1, 4)가 2022, Slicer(key, 6, 1)가 3일 때 Array_GetByYearMonth(Slicer(key, 1, 4), Slicer(key, 6, 1);의 결과는 아래와 같다. 

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
['데자와', '수성', '솔의눈', '금성', '지구', '제로코크', '목성', '토성', '하늘보리']
</code>
</pre>
              
          이 결과엔 2022년 12월, 2022년 10월, 2022년 3월의 콘텐츠들이 다 들어가 있다. 2022년 1월만 빠졌다. <br><br>
          
          여기서 뭔가 감이 왔다. 함수를 설계한 과정은 아무리 봐도 오류가 없다. 그러면 사용한 함수가 전제로 하고 있는 또 다른 요소가 문제를 일으켰다고 볼 수밖에 없는 것이다. 예를 들면 나는 2022년 3월 콘텐츠 배열을 만들으라고 했지만 내가 생각하지 못한 문제 때문에  2022년 3월부터의 콘텐츠를 싹 모아온다든지. 하여, Array_GetByYearMonth();에 사용된 함수를 살폈다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function Array_GetByYearMonth(연, 월){
  //-&gt; '연'은 네 지리. ex) 2022. '월'은 한 자리나 두 자리 ex) 7, 12
    let a = (연.toString() + Plus0(월)) * 100;
    let b = (연.toString() + Plus0(월+1)) * 100;
    let c = [];
    for(let key in 전체글){
      if(a &lt; key &amp;&amp; key &lt; b){
        for(i = 0; i &lt; Categories.length; i++){
          if(전체글[key][Categories[i]] !== undefined){
          c = c.concat(전체글[key][Categories[i]])
          }
        }
      }
    }
    return c;
  };
</code>
</pre>
            
          이 함수는 매개 변수로 입력된 '연', '월' 값을 가공해 목표로 하는 key의 범위를 정한다. 그러니까, '연', '월' 자리에 '2022', '3'을 넣으면 a, b 변수 선언 과정을 통해 ('2022' + '03')*100 &lt; key &lt; ('2022' + '04')*100을 만족하는 key를 구하고 반복문에 적용시키는 것이다. 여기까지 보니 확실히 감이 왔다. 아, 변수 b의 가공 과정에서 연산에 문제가 생겼나 보다. 다시 말해, '숫자형'과 '문자형'이 꼬여서 연산이 의도치 않은 방향으로 벌어졌을 수 있겠다! <br><br>
          
          가설을 세워봤다. 매개 변수로 '2022'와 '3'이 삽입됐다. 의도한 결과는 a가 '20220300', b가 '20220400'이 나와 key의 범위를 20220300 &lt; key &lt; 20220400 이렇게 한정지어주는 것이다. 객체의 key 중에 이 조건에 만족하는 key는 +20220303, +20220330 두 가지고 그 둘의 요소는 ['제로코크', '목성', '토성', '하늘보리']다. <br><br>
          
          그런데 b를 구하는 과정에서 사용된 Plus0(월+1)가 3 + 1 해서 Plus0(4)가 된 게 아니라, '3'(string) + 1(number)로 해서 Plus0('31')이 됐다면..? key의 범위는 20220300 &lt; key &lt; 20220400가 아니라 20220300 &lt; key &lt; 20223100이 된다. 이걸 만족하는 key는 '+20220330', '+20220303', '+20221010', '+20221212' 이렇게 네 가지. 즉, 2022년 3월, 2022년 10월, 2022년 12월의 콘텐츠가 모두 합쳐진 배열이 나온다. 그리고 그 배열은.. 이전에 본 적이 있었다. 위에서 죽어도 9개가 나와서 미쳐버리겠다는 그 배열.. 바로..! <br><br>
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
['데자와', '수성', '솔의눈', '금성', '지구', '제로코크', '목성', '토성', '하늘보리'] 
</code>
</pre>
         
          !!! <br><br>
          
          이제 이 난리의 원인이 무엇이었는지 확실히 알 수 있었다. '문자형'과 '숫자형'을 부주의하게 섞어 쓴 것.. Array_GetByYearMonth(연, 월)이 함수의 매개 변수로 2022, 3 같은 숫자를 넣으면 Plus0(월+1) 부분이 의도한 대로 '숫자 + 숫자' 연산이 되지만, Slicer(key, 6, 1)를 매개 변수로 넣어버리면 '문자 + 숫자' 연산이 되어 '합산'되는 게 아니라 횡으로 '결합' 되어버린다. 즉 Plus0(4)가 되었어야 하는 것이 Plus0('31')이 되는 것이다. Plus0(a); 함수의 코드는 아래와 같다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
function Plus0(a){
  if(a &lt; 10){
    a = '0' + a
  }
  return a;
};
</code>
</pre>
          
          하여 Plus0('31')의 결과는 그대로 '31'이다. 4가 되어야 하는 게 '31'이 되었느니.. 예상하던 결과가 나와줄 리가 없는 것이다. <br><br>
          
          그렇다면 해결책은 무엇일까. Array_GetByYearMonth(연, 월)에 들어가는 매개 변수를 숫자로 만들어 넣어줘야 한다. 아까 문제가 된 함수 Sidebar_List_YearMonth();에서 나는 Array_GetByYearMonth(연, 월)의 매개 변수로 Slicer(x, y, z); 함수의 결과값을 사용했고 예상한 결과값을 얻을 수 없었다. 즉, Slicer(x, y, z);는 결과값으로 '문자형'을 내놓는다는 것이다. <br><br>
          
          그러니까 현재 봉착한 문제를 해결하기 위해선, Slicer(x, y, z); 함수의 리턴값을 '문자형'에서 '숫자형'으로 바꿔줘야 한다! <br><br>
          
          Slicer(x, y, z); 함수의 코드는 이랬다. <br><br>
          
          코드:
           
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;key 문자열 자르기 함수&gt;

function Slicer(x, y, z){
  return x.substr(y, z);
};
</code>
</pre>
                   
          Number(a); 함수를 사용해 기존의 리턴값을 '숫자형'으로 바꿔줬다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// &lt;key 문자열 자르기 함수&gt;

function Slicer(x, y, z){
  let a = x.substr(y, z);
  return Number(a);
};
</code>
</pre>
                  
          자, 이제 사건의 발단이었던 Sidebar_List_YearMonth(); 함수로 돌아와 함수를 실행시켜보자..! <br><br>
          
          결과:

          <!-- 이미지 -->
          
          할렐루야!!! 감사합니다.. 정말 감사합니다.. <br><br>
          
          이번 고초를 계기로 '문자형', '숫자형'을 항상 신경 써야겠다는 생각을 했다. 정말이지 뼈저리게.. <br><br>
          
          Sidebar_List_YearMonth(); 함수를 짜며 나 자신을 의심했음을 반성한다. 역시 설계 자체는 틀리지 않았다. 그걸 믿지 못하고 수많은 시간을 의심하고 또 의심하고.. <br><br>
          
          결과:

          <!-- 이미지 -->
          
          <br><hr><br>

          <h2>&lt;ㅇ.ㅇ7&gt; 게시글 앞에 작성일 표시</h2>
          
          <p>솔직히 작성일 같은 건 전혀 중요하지 않을지도 모르겠다. 나 또한 뻔질나게 인터넷을 드나들며 수많은 글들을 검색해대지만, 그 글의 작성일이 언제인지는 보통 신경 쓰지 않는다. 그것은 내게 특별한 의미로 읽히지 않으니까. 그 안의 정보가 최신인지 혹은 어느 정도나 낡았는지 가늠해봐야 할 때나 슬쩍 본다. 그것도 그냥 연도 정도만. <br><br>
          
          그치만 내가 생산해낸 무언가에 대해서만큼은 그 탄생일일이 어떤 의미를 가지고 다가오는 경우가 왕왕 있다. 우리 모두는 각자 고유한 시간을 겪어낼 테니까. 타인이 보기에는 그저 여섯 자리 숫자일지라도, 당사자에게는 그때의 나, 라는 문맥이 더해지는 것이다. 그런 의미에서 내가 작성일을 표시하려는 이유는, <br><br>
          
          그냥 그게 예쁠 것 같아서.. <br><br>
          
          목표:

          <!-- 이미지 -->
          
          하는 김에 게시물들을 일정한 단위의 페이지로 묶는 기능도 만들어볼 작정이다. <br><br>
          
          이미 분류 방법별로 목록을 뽑아주는 함수를 가지고 있었다. 반복문으로 key를 돌려주는 반복문 중간에 날짜를 표시하는 코드를 삽입해주기만 하면 됐다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// 모든 글의 제목을 출력해주는 함수

function Main_List_AllPosts(){
  let a = [];
  for(let key in 전체글){
    for(i = 0; i &lt; Categories.length; i++){
      if(전체글[key][Categories[i]] !== undefined){
        for(j = 0; j &lt; 전체글[key][Categories[i]].length; j++){
          a = a.concat('&lt;span style = "font: italic 13px D2coding; color: ;"&gt;' + Slicer2(key, 3, 2) + '/' + Slicer2(key, 5, 2) + '/' + Slicer2(key, 7, 2) + '&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="' + 전체글[key][Categories[i]][j] + '.html"&gt;' + 전체글[key][Categories[i]][j] + '&lt;/a&gt;&lt;br&gt;')
        }
      }
    }
  }
  for(i = 0; i &lt; a.length; i++){
    document.write(a[i]);
  }
}
</code>
</pre>
          
          기존의 출력 함수에 추가해준 부분은 이 부분이다.
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;span style = "font: italic 13px D2coding; color: ;"&gt;' + Slicer2(key, 3, 2) + '/' + Slicer2(key, 5, 2) + '/' + Slicer2(key, 7, 2) + '&lt;/span&gt;
</code>
</pre>
          
          결과: <br><br>
          
          -&gt; 처음엔 월, 일이 한 자릿수일 때, 예를 들어 22년 7월 6일이면 22/7/6 이렇게 하려고 했는데 하고 보니 날짜 부분이 들쭉날쭉해져서 모두 두 자릿수로 맞춰줬다. 편안해졌다. <br>
          -&gt; 또 처음엔 날짜랑 게시물 전체를 그냥 &lt;a&gt; 태그로 묶어버리려고 했는데, 마우스 호버를 하면 날짜에까지 언더라인이 그려져서 안 이뻤다. 그래서 날짜 부분은 &lt;span&gt; 태그로 따로 감싸서 링크를 먹지 않게 만들었다. <br>
          -&gt; 같은 폰트로 날짜랑 제목을 나란히 놓아놓으니 구분감이 별로라서 어차피 &lt;span&gt;으로 따로 묶은 김에 폰트를 조절해줬다. 색깔도 구분지어줄까 했는데 그건 좀 과한 것 같아서 냅뒀다. <br>
          -&gt; &lt;span&gt; 태그는 inline! &lt;p&gt;는 block! 까먹지 말자. 그리고 inline-block은 인라인 속성과 블록 속성을 동시에 가지고 있다! </p>

          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ8&gt; 페이지네이션 배우기</h2>
          
          <p>새학기가 시작될 때쯤, 대학가 다이소는 수납 용품 대목을 맞이한다. 텅 비어 있는 방을 갖게 된 대학생들이 필요한 용품들을 사들여대고 나면, 비로소 각종 물건들이 늘어져 너저분한 방을 마주하게 되기 때문이다. <br><br>
          
          블로그도 마찬가지다. 아무리 명작들이 올려져 있다고 해도 그것들이 그저 흘러넘치게 둬서는 심미적으로 거부감이 드는 것이다. 페이지네이션이라는 것은 일종의 수납함으로, 그것의 기본 정신은 이렇다. 보일 것만 보이고 싹 다 감춰라. <br><br>
          
          검색어: javascript 페이지로 분류 <br><br>
          
          정확한 명칭을 몰라서 이런 정도로 검색해봤다. 보아하니 이 기능을 pagination이라고 부르는 모양이었다. <br><br>
          
          검색어: javascript 페이지네이션 <br><br>
          
          페이지네이션을 설명하는 여러 블로그들을 읽었는데 이거야 잘 이해가 안 됐다. 최대한 영상 말고 글로 배워보자는 생각이 있어서 글 위주로 계속 찾아봤다. 영상은 아무래도 교수자가 하는 걸 그저 따라가고선 그게 내 실력이라고 속아버리게 되기 쉬우니까. 하지만 글을 읽을수록 머리만 아팠다. 그러다 검색 때마다 걸리던 유튜브 강의를 슬쩍 봤다. 그리고 깨달았다. <br><br>
          
          이거다..! <br><br>
          
          대충 띄엄띄엄 들어봐도 이해가 쏙쏙 됐다. 그리고 교수자분이 코드를 슥슥 작성하며 문제를 풀어내는 걸 보곤, 그게 무엇일진 일단 모르겠지만 분명 내가 이 영상에서 페이지네이션 말고도 배워야 할 점이 있다는 확신이 들었다. 뭐 잘 알지도 못하면서 영상을 배제하려던 나 자신을 엄히 꾸짖곤 영상 속 목소리로만 존재하는 선생님의 수업을 수강했다. <br><br>
          
          제목: javascript 73 [테이블 페이지네이션] ES6 바닐라 자바스트립트로 페이지네이션 구현 파트1/4 <br>
          링크: https://youtu.be/drXZCq3Y9d8 <br><br>
          
          영상에서 가르쳐준 내용을 이해하는 건 쉬웠다. 하지만 그걸 습득해내는 데는 시간이 많이 걸렸다. 완전 이해했다고 생각하고 나서도 직접 페이지네이션 예제 코드를 짜보려니 몇 발 못 가 더는 전진할 수가 없었다. 그렇게 멈춰 선 채로 고민을 거듭하다가 어찌어찌 코드를 짜내고.. 다시 강의를 보면 굉장한 오답이고.. 웬만큼 혼자 해낼 수 있었으면 그냥 넘어가겠는데, 잘 안 되니까 코드를 지우고 다시 해보고 또 다시 해보고,, 그래서 시간이 많이 걸렸다. 마침내 예제 코드를 혼자 완성했을 때는 거의 울 뻔했다. <br><br>
          
          강의를 보기 잘했다는 생각을 했다. 강의에서 페이지네이션 기능 자체를 배운 것도 있었지만, 코드를 짤 때 어떤 식으로 생각해야 하는지를 나름 알게 됐기 때문이다. 교수자는 단계별로 해결해야 할 문제를 생각하고, 결국 최종적으로 무엇을 해내야 할지 목표를 정하고, 거기에 도달하기 위해 필요한 변수는 뭔지, 그 변수가 필요한 이유는 무엇인지가 말했다. 그리고 그대로 코드를 짜나갔다. 굉장히 쉬워 보였다. 그리고 무엇보다, 그렇게 하는 게 당연해 보였다. 최종적으로 이걸 해야 되니까 일단 이 단계를 거쳐야겠구나, 이 단계를 진행하려면 이런이런 변수가 필요하니까 만들어야겠구나. <br><br>
          
          나 혼자 코드를 짜볼 때 시간이 상당히 많이 걸렸던 건 바로 그 지점이었다. 영상 속의 저 사람처럼 생각하기, 가 잘 안 됐다. 강의를 볼 때는 당연한 사고의 흐름이라고 생각했던 게 아무것도 없이 내가 해보려니 이거야 잘 되지 않았다. 왜냐면, 나는 그런 식으로 사고하는 데 익숙치 않았으니까. 나는 뭐랄까,, 변수를 만들고 함수를 짜는 데 합당하고 당연한 이유 없이 코딩을 해왔다는 생각이 들었다. 기존에 갖고 있는 지식만 들고선 음.. 이렇게 하면 될 것 같은데? 해서 여차저차 해보고 console.log 찍어보고, 안 되면 다시 또 음.. 저렇게 하면 되려나? 해서 이렇게 저렇게 해보고. 말하자면 이런 식으로 어떤 이유나 체계가 분명하지 않은 상태에서 얼렁뚱땅 전진하고 있던 것이었다. 횡재들은 쌓여도 좀처럼 실력이 되질 않는데. <br><br>
          
          고등학교 때 수시 논술을 준비했었다. 학교에서 불러준 논술 선생님은 논술엔 답이 없다고 했다. 책을 많이 읽는 수밖에 없다고. 매주 그 선생님이 뽑아오는 프린트물, 그러니까 책을 발췌한 글들을 읽으며 논술 수련을 했다. 근데 해도 뭐.. 나아지는 건 없었다. 근데 그 선생님뿐 아니라 대부분의 선생님들이 그렇게 말했다. 논술엔 답이 없다고. 니 생각을 쓰면 되는 거라고. <br><br>
          
          그러다 논술 시험에도 당연히 답이 있다고 말하는 선생님을 알게 됐다. 학교에서 초빙한 논술 쌤 수업을 나와 그 선생님의 인강을 들었다. 그분 이름이 아마 권대승이었나. 그 쌤은 논술 문제들을 무슨 수학 선생님이 수학 문제를 풀듯 풀었다. 그냥 슥슥. 문제를 읽고는 지문에서 뭘 찾아내야 하는지를 발견해내고, 그걸 기준으로 지문을 읽으며 표를 그렸다. 지문의 내용을 표로 정리해낸 다음 문제에서 요구한 규칙에 따라 표 안에 정리된 문장들을 문제에 맞춰 적당히 써넣었다. 그러자 답이 나왔다. 무엇보다 그건 정말 답인 것처럼 느껴졌다. 모두 논술은 답이 없다고 했지만. <br><br>
          
          그 선생님의 설명을 들으면 나 혼자선 의도조차 알아차리지 못했던 문제가 한없이 쉬워졌다. 그리고 무엇보다, 이렇게 푸는 게 맞다는 확신이 들었다. 그런 건 그냥 알 수 있다. 느낌이니까. 물증은 없어도 수험생 특유의 잔뜩 벼려져 있는 촉이 확실한 심증이 됐다. 그 선생님의 사고 방식을 쫓았다. 표를 그리는 거나 하는 건 그저 스킬이었다. 일단 문제를 어떻게 풀어낼 것인지 생각하는 게 중요했다. 해결해내야 할 게 뭐고 그러면 지문에서 무엇을 뽑아내야 하는지. 말하자면 적확한 전략을 세워내는 사고 방식, 그걸 훔쳐내야 했다. <br><br>
          
          문제를 두고 그 쌤처럼 생각해내려 애썼다. 처음엔 당연히 안 됐다. 쌤의 강의를 듣고 답을 다 알고 있었어도 혼자 하면 그 사고의 흐름이 안 나왔다. 어딘가에서 막혔다. 매일 똑같은 문제를 풀었다. 문제의 답을 찾아내는 게 중요한 게 아니었다. 그 쌤처럼 생각해서 풀어내는 게 관건이었다. 몇 개의 문제와 답안지까지 외워낼 지경이 되자 나도 조금 수월해졌다. 이제 새로운 문제를 맞딱뜨려도 얼추 풀어낼 수 있었다. 사고의 단계가 그려졌다. 풀고 나서 그 쌤의 해설을 들었다. 그 쌤의 해설과 내가 생각한 방식이 맞아떨어졌을 때, 희열이 일었다. <br><br>
          
          그해 입시에서 대학 논술 시험을 통과한 게, 우리 학교에서 아마 나뿐이었다. <br><br>
          
          쓰다 보니 말이 길어졌는데,, 아무튼 페이지네이션 강의를 들으면서 10년 전 논술 인강을 들을 때의 실감이 들었다. 코딩에서 마주하는 문제는 이런 방식으로 생각해서 풀어야 되겠구나, 라는. 그때의 논술에서처럼 훔쳐내는 수련을 해야 하는 것이다. <br><br>
          
          그런 말을 읽은 적이 있다. 누가 하는 일이 쉬워 보이면 그 사람은 그 일을 정말 잘하고 있는 거라고. 종종 체감할 수 있다. 직장에 들어가 어떤 일을 처음 하게 되면 굉장히 어렵고 벅차다. 그 많은 일들을 샤샤샥 처리해내는 사수가 그야말로 대단해 보인다. 그러다 문득 시간이 지나서 보면, 나도 그 일들을 샤샤샥 처리해내고 있다. 종종 여유롭게 담배도 피우러 나갔다 오면서. 그리고 새로 들어온 신입이 말한다. 선배는 어떻게 그 많은 일들을 그렇게 쉽게 하세여..? <br><br>
          
          강의를 들을 때는 무엇이든 쉬워 보인다. 그것을 쉽게 느껴지게 하는 수준에 도달하는 건 어렵다. <br><br>
          
          페이지네이션 강의 하나 들은 거 가지고 글이 참 길어졌다. 다음엔 배운 걸 내 블로그에 적용해보겠다. <br><br>
          
          예제 결과:

          <!-- 이미지 -->

          </p>

          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ9&gt; 페이지네이션 적용</h2>
          
          <p>자, 이제 간신히 익힌 페이지네이션을 블로그에 적용할 시간이다.

          <!-- 이미지 -->
    
          2번. <br><br>
          
          그러나.. 페이지네이션 구현을 향한 첫 발자국부터 아주 큰 벽을 만나고 말았다.. <br><br>
          
          페이지네이션의 핵심은 해당 페이지 버튼을 클릭했을 때 감춰질 자료와 보여질 자료를 지정해내는 거다. 물론 아닐 수도 있지만.. 내 짧은 소견으로는 그렇다. 그래서 첫 단계의 목적지는 특정 자료들의 범위를 변수에 담아서 element.style.display = 'none';을 해주는 거다. 보여질 자료들엔 'none'; 부분을 ' ';으로 바꿔준다. <br><br>
          
          그렇다면 숨김과 보여짐의 대상이 될 자료들을 선택해내야 한다. 나는 일단 '모든 글' 목록에 페이지네이션을 적용하려고 했기 때문에 그 목록에 출력되는 자료들을 document.querySelectorAll();로 선택해내려 했다. 그러니까, 

          <!-- 이미지 -->
        
          여기에 있는 39개의 '날짜 + 콘텐츠 하이퍼링크들'의 코드를 선택해내는 거다. <br><br>
          
          우선 모든 글 카테고리의 '날짜 + 콘텐츠 하이퍼링크들' 출력 함수에 &lt;p&gt;태그를 추가하고 거기에 id = "Posts"를 넣어줬다. <br><br>

          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
// 모든 글 카테고리 콘텐츠 출력 함수

function Main_List_AllPosts(){
  let a = [];
  for(let key in 전체글){
    //-&gt; 모든 발행일에 대해 반복
    for(i = 0; i &lt; Categories.length; i++){
      //-&gt; 그리고 모든 카테고리에 대해 또 반복
      if(전체글[key][Categories[i]] !== undefined){
        for(j = 0; j &lt; 전체글[key][Categories[i]].length; j++){
          a = a.concat('&lt;p id = "Posts" style = "display: inline"&gt;&lt;span style = "font: italic 13px D2coding; color: ;"&gt;' + Slicer2(key, 3, 2) + '/' + Slicer2(key, 5, 2) + '/' + Slicer2(key, 7, 2) + '&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="' + 전체글[key][Categories[i]][j] + '.html"&gt;' + 전체글[key][Categories[i]][j] + '&lt;/a&gt;&lt;br&gt;&lt;/p&gt;')
        }
      }
    }
  }
  for(i = 0; i &lt; a.length; i++){
      document.write(a[i]);
  }
}
</code>
</pre>
          
          다음으로 스크립트 문서에 Posts 상수를 선언하고 우변에 쿼리셀렉터 메서드를 써넣었다. <br><br>
          
          코드:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
const Posts = document.querySelectorAll('.ContentSpace #Posts');
</code>
</pre>
          
          그리고 console.log(Posts)를 해주면 콘텐츠 숫자만큼 39개의 NodeList가 나와야 한다. 그렇다. 나와야 한다. 나와야 하는데.. <br><br>
          
          예상: 

          <!-- 이미지 -->
          
          현실:

          <!-- 이미지 -->
          
          나의 쿼리셀렉터는 html 문서에서 멀쩡히 눈 뜨고 있는 ('.ContentSpace #Posts')를 전혀 잡아내지 못했다.. </p>
          
          <p>나는 컴퓨터가 실수할 리는 없다고 생각했다. 나는 이세돌이 아니니까. 간단한 js 코드에서 문제가 발생했다면, 문제의 원인은 컴퓨터보다는 당연히 나였다. 몇 번이나 코드를 고쳤다. 혹시 실수한 게 있나  따졌다. 쿼리셀렉터는 원래 p태그를 잡아내지 못하나? 라는 생각에 i태그도 span태그로도 시도해봤다. 그리고 페이지네이션 강의에서 쓰였던 tr 태그로까지 쿼리셀렉팅을 실패하고 나서야 뭔가가 '근본적으로' 잘못됐다는 생각이 들었다. 내가 알아낼 수 없는 '뭔가'가 잘못됐다. 검색을 했다. <br><br>
          
          검색어: querySelector 안 됨 <br><br>
          
          같은 문제를 겪는 사람들이 올려놓은 질문들이 있었다. 그 질문에 대한 답변에서 현재의 문제에 대한 원인을 짐작해낼 수 있었다. <br><br>
          
          질문: https://okky.kr/articles/655641 <br>
          답변: https://jeong-pro.tistory.com/90 <br><br>
          
          내가 이해한 바로는, 컴퓨터가 html 문서를 렌더링 하는 과정엔 순서가 있고, 내가 작성한 코드의 어느 부분이 html의 내용보다 script 내용을 먼저 불러와 적용시켰기 때문에 html 내용을 script에 쓰인 코드로 잡아내질 못했다는 게 문제의 원인이었다. 대충 이해가 갔다. html 문서의 내용이 있어야 그 내용을 타겟으로 하는 script의 코드(쿼리셀렉터)가 제대로 작동할 것이니까. <br><br>
          
          그리고 해결 방법을 찾아나섰다. <br><br>
          
          해결책: https://blog.asamaru.net/2017/05/04/script-async-defer/ <br><br>
          
          이 과정에서 알게된 것이 스크립트 문서와 연결시키는 코드는 보통 &lt;/body&gt; 바로 앞에 써넣는다는 것이었다. 왜냐면,, html이 다 읽힌 다음에 js가 작동해야 하니까!!! js가 정적인 html을 가지고 이런저런 기능들을 하게 하는 언어라고 배웠는데 그게 이제야 떠올랐다. 그러면 당연히 html이 먼저 있어야지.. <br><br>
          
          하지만 나는 그런 거 몰랐다.. 애초에 문서의 종류마다 읽히는 순서가 있다는 사실도 몰랐다.. <br><br>
          
          링크로 적어놓은 문서에는 스크립트 연결 코드에 anync나 defer 속성을 추가해 html 문서와 script 문서가 읽히는 순서를 조정할 수 있는 방법을 소개되어 있었다. 하여 희망을 갖고 모두 적용시켜봤지만.. 문제는 해결되지 않았다. <br><br>
          
          내 코드는 왜 저 방법으로 해결되지 않을까.. 나는 비탄에 빠져 내가 짜놓은 코드를 살펴봤다. 이것도 내 미천한 추측이지만, 답은 간단했다. 내가 html 문서에 function();을 너무 남발해놓은 게 원인이었던 것이다ㅠㅠ. script 문서와의 연결 링크를 &lt;/body&gt; 바로 밑에 두거나 anync, defer를 추가해 html을 먼저 다 읽고 나서 외부에 있는 스크립트 문서를 적용하라고 명령하면 html 문서 곳곳에 심겨져 있는 function들이 작동하지 않아 오류가 잔뜩 생겼다. 그렇다고 html을 읽다가 function을 만나고 그대로 html 해석을 중지한 채 스크립트 문서를 읽어버리면, 아까와 같은 상황 즉, html을 기반으로 작동해야 할 js 기능들이 작동할 수가 없다. 왜냐면 그 기능들은 html을 재료로 작동하니 먼저 html 처리가 완료되어야 정상 작동할 수 있기 때문이다. 내 function을 마구 남발한 빌어먹을 코드가 html이든 js든 어느 쪽에도 우선권을 넘겨줄 수 없는 사면초가의 상황을 만들어낸 것이다! <br><br>
          
          나는 왜 html 문서에 function();을 사용하는 데 주저함이 없었을까.. 몰랐으니까!!! 독립될 줄 몰랐으니까!!! 총알이 두 개지요.. <br><br>
          
          그게 문제가 될 코딩 방식이란 걸 알지 못했다. function();을 좀 다룰 줄 알게 되고는 펑션의 차라리 마법 같은 매력에 빠져 흥청망청 사용하고 다녔다. 지적해줄 누군가가 있었으면 좋았을걸.. 그랬다면 쿼리셀렉터로 요소 하나를 못 잡아서 이 고생을 하고 있지도 않았겠지..? 어딘가 코칭해줄 사람이 있는 곳에 들어가 배워야겠다는 생각이 더욱 굳건해졌다. </p>
          
          <p>다른 해결책이 있나 수소문하고 다닐수록 결국 양자택일을 할 수밖에 없는 상황이라는 점이 확연해졌다. 해결책은 두 가지였다. <br><br>
          
          1. html 문서 내부에 function();이 들어가지 않게 js 코드들을 다시 짠다. 즉, 싹 갈아엎는다. <br><br>
          
          2. 페이지네이션 적용을 포기한다. <br><br>
          
          첫 번째 방법을 선택하면 <br><br>
          
          -&gt; 오류의 원인을 근본적으로 제거할 수 있다. <br>
          -&gt; 하나하나 고쳐내며 실력을 향상시킬 수 있다. <br>
          -&gt; 시간이 아주 많이 걸릴 것으로 예상되며, <br>
          -&gt; 기존의 기능을 대체할 코드를 배우고 만들 생각을 하니 벌써 머리가 지끈거린다. <br>
          -&gt; 무엇보다,, 내겐 시간이 별로 없다.. <br>
          -&gt; 일단 목표로 한 날까지 뭔가를 만들어내고 다음에 수정해도 될 것이다. <br>
          -&gt; 그래,, 다음에 수정해도 되지.. 다음에.. <br><br>
          
          두 번째 방법을 선택하면 <br><br>
          
          -&gt; 아주 깔끔하다. 하나도 해결되지 않지만, 반대로 무엇도 해결할 필요가 없어진다. <br>
          -&gt; 언젠가 대가를 치르게 될 것이다. <br>
          -&gt; 평생 마음의 짐으로 남아 나를 괴롭힐 수 있다. <br><br>
          
          긴긴 고민의 시간 끝에, 포기하기로 했다. 일단은 시간 안에 그럴 듯한 뭔가를 완성해내는 걸 목표로 하기로 했다. <br><br>
          
          하지만,, 내가 누구..? 정웅비.. 포기를 모르는 남자지.. 나는 쉽사리 이것을 포기해내지 못한 채 오류의 주위를 맴맴 맴돌았다. 잊어버리자 하고서도 문득 이러면 되지 않을까? 라는 생각에 다시 돌아와 시도해보고.. 또 고배를 마시고.. <br><br>
          
          그나저나 '포기를 모르는 남자지..'라는 정대만의 명대사는 한국어 번역 과정에서 원문의 뉘앙스가 삭제되어 미묘하게 다른 의미가 되어버렸다고 한다. 원문에서는 중학 MVP 시절의 영광도 농구에 대한 미련도 끝내 포기해버린 채 방황하던, 그 결과 풀타임 경기조차 제대로 소화해내지 못하게 된 자신에 대한 후회 그리고 자학적 뉘앙스가 함유되어 있는 대사였기 때문이다. 즉, 정대만은 '포기를 모르는 남자'라는 말로 자신을 지칭하며 흡사 포기 전문가였던 과거의 자신에 대한 후회스러운 마음까지 드러내고 있는 것이다. 하지만 한국어 번역본에선 그 미묘한 뉘앙스가 빠져, 정대만은 그저 어려운 경기 상황 속에서도 포기하지 않는 투지의 화신이 되었다.. 고 어디서 읽었다. 그러고 보니 그런 것 같기도 하고.. 또 생각해보면 한국어 대사에서도 그런 뉘앙스를 충분히 추측해낼 수 있는 것 같기도 하고.. 원문을 해석해낼 능력이 없으니 뭐 비교는 힘들겠지만. <br><br>
          
          또 이야기가 딴 길로 샜다..! 다시 돌아와, 나는 페이지네이션에 미련을 버리지 못한 채 서성임을 반복하다가 불현듯 방법을 찾아냈다. 참고했던 페이지에서 본 그림이 번뜩 생각난 것이다.

           <!-- 이미지 -->
          
          이 그림에 대한 설명은 이렇게 되어 있다. <br><br>
          
          일반적인 실행: (...) 기본적으로 &lt;script&gt;는 인라인 코드의 경우 즉시 해석되고 실행될 수 있지만 그렇지 않은 경우는 해당 파일을 가져올 때까지 HTML 문서의 구문 분석을 중단한다. (...) <br><br>
          
          내가 주목한 곳은 이 부분이다. <br><br>
          
          "&lt;script&gt;는 인라인 코드의 경우 즉시 해석되고 실행"!!! <br><br>
          
          그러니까, 그냥 html 문서에 script 코드를 때려넣으면 일단 작동은 시켜준다는 것이다! html 문서에 바로 쿼리셀렉터를 써넣고 console.log를 찍어봤다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;script&gt;
const Posts = document.querySelectorAll('.ContentSpace #Posts');
&lt;/script&gt;
</code>
</pre>    
          
          결과:

          <!-- 이미지 -->
          
          된다ㅠㅠ.. 하여, 페이지네이션 구현을 위해 나는 html 문서 한복판에서 js를 외치게 되었다. 페이지네이션 구현 코드는 다음과 같다. <br><br>
          
          <!-- 이미지 -->
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;p id = "List"&gt;
&lt;script&gt;
Main_List_AllPosts();
// -&gt; 리스트 출력 함수. 여기서 출력된 요소들이 스크립트 문서에서는 쿼리셀렉터로 잡히질 않았다. 그래서 이 사단을 벌임.
&lt;/script&gt;
&lt;/p&gt;

&lt;br&gt;
&lt;br&gt;

&lt;p class = "Pagination" style="text-align: center"&gt;
&lt;!-- &lt;input id = "LeftDoubleArrow" type = "button" value = "&lt;&lt;" onclick = ""&gt; --&gt;
&lt;input id = "LeftArrow" type = "button" value = "&lt;" onclick = ""&gt;

&lt;script&gt;

  const Posts = document.querySelectorAll('.ContentSpace #Posts');
  // -&gt; (날짜 + 목록) 리스트를 선택. 즉, 앞서 사용된 Main_List_AllPosts();로 출력된 &lt;p id = "Posts"&gt;에 속한 요소들을 선택해 노드리스트로 만든다.
  const PostsPerPage = 5;
  // -&gt; 한 페이지에 들어갈 콘텐츠의 수 지정. 필요한 총 페이지 수를 구하기 위함.
  const PostsCount = Posts.length;
  // -&gt; 전체 콘텐츠의 수. 필요한 총 페이지 수를 구하기 위함.
  const PageCount = Math.ceil(PostsCount/PostsPerPage);
  // -&gt; 전체 콘텐츠 / 한 페이지 들어갈 콘텐츠 수, 연산으로 필요한 총 페이지 수를 구한다.

  for(i = 1; i &lt;= PageCount; i++){
    document.write('&lt;button&gt;' + i + '&lt;/button&gt;');
  }
  // -&gt; 버튼 형식으로 페이지들을 만든다.

&lt;/script&gt;
&lt;input id = "RightArrow" type = "button" value = "&gt;" onclick = ""&gt;
&lt;!-- &lt;input id = "RightDoubleArrow" type = "button" value = "&gt;&gt;" onclick = ""&gt; --&gt;

&lt;script&gt;

  const PageBtn = document.querySelectorAll('button');
  // -&gt; 앞서 만든 페이지 버튼들을 선택한다. 클릭 시 실행될 기능을 설정해주기 위함.

  PageBtn.forEach(function(item, index){
  // -&gt; 클릭된 페이지의 인덱스를 활용하여 감추고 보여줄 자료의 범위를 지정해줄 것. index와 연계해 사용할 수 있는 반복문 forEach를 썼다.
    item.addEventListener('click', function(event){
    // -&gt; 이벤트리스너로 페이지 버튼이 클릭되면 실행할 기능을 설정.
      ClickPageBtn(index)
      // -&gt; 클릭되면 그 이벤트가 발생한 요소에 대해 이 함수를 실행시켜줄 거다. 만들자.
    })
  })

  function ClickPageBtn(index){
  for(let p of Posts){
        p.style.display = 'none';
      }
      // -&gt; 버튼 클릭 시 일단 모든 페이지를 숨겨준다.
      /*
      btn 1[0] -&gt; Posts 1 2 3[0 1 2] -&gt; Posts.Slice(0, 3)
      btn 2[1] -&gt; Posts 4 5 6[3 4 5] -&gt; Posts.Slice(3, 6)
      */
      // -&gt; 보여줄 자료들을 지정할 때 slice(); 메서드를 사용할 것.
      let begin = index*PostsPerPage;
      let end = begin + PostsPerPage;
      // -&gt; 클릭된 페이지 버튼의 인덱스에 연계해 슬라이스 안에 들어갈 숫자들을 변수에 담는다.
      let PostsArray = [...Posts];
      // -&gt; 쿼리셀렉터로 선택한 Posts는 NodeList이기 때문에 그대로는 .slice();로 처리할 수 없다. 전개연산자를 이용해 형태를 진짜 배열로 바꿔준다. 
      let SlicedPostsArray = PostsArray.slice(begin, end);
      for(let spa of SlicedPostsArray){
        spa.style.display = '';
        spa.style.display = 'inline'
        // -&gt; 보여져야 할 배열의 요소에 대해 반복문으로 display 속성을 바꿔준다.
      }
      for(let pb of PageBtn){
        pb.classList.remove('active');
      }
        PageBtn[index].classList.add('active');
        // -&gt; 현재 클릭된 페이지 버튼을 표시하기 위해 클릭되면 버튼 요소에 active 클래스를 추가해준다. css에서 active 클래스의 디자인을 바꿔 구분.
    }

    ClickPageBtn(0);
    // -&gt; 목록으로 들어와서 첫 화면에 페이지버튼 1을 클릭한 화면을 보여준다. 디폴트값.

    // 이제 페이지버튼이 몇 개까지 표시될 건지도 지정해준다.
    const PagePerMetaPage = 3;
    // -&gt; 화면에 표시될 페이지 버튼의 수.
    const MetaPageCount = Math.ceil(PageCount/PagePerMetaPage);
    // -&gt; 페이지 버튼은 총 몇 개의 그룹으로 나뉠 것인지 계산.
    let DefaultMetaPage = 0;
    // -&gt; '&gt;' 버튼이 클릭될 때마다 그룹 인덱스를 하나씩 올려줄 거라 디폴트값은 우선 0으로 줬다.
    const LeftArrow = document.querySelector('#LeftArrow');
    const RightArrow = document.querySelector('#RightArrow');
    // -&gt; 페이지 버튼 그룹 이동을 위한 '&lt;', '&gt;' 버튼을 선택. 이 버튼에 이전/다음 그룹으로 이동시킬 기능을 부여할 거다.
    // const LeftDoubleArrow = document.querySelector('#LeftDoubleArrow');
    // const RightDoubleArrow = document.querySelector('#RightDoubleArrow');

    /*
    MetaPage 1[0] -&gt; Btn 1 2 3 4 5[0 1 2 3 4] -&gt; slice(0, 5)
    MetaPage 2[1] -&gt; Btn 6 7 8 9 10[5 6 7 8 9] -&gt; slice(5, 10)
    */

    function ShowAndHidePageBtn(DefaultMetaPage){
      // -&gt; 페이지 버튼을 조정하는 함수. 이전에 특정 자료만 숨기고 보여주는 함수와 기본적으로 비슷한 메커니즘을 갖는다.
      for(let pb of PageBtn){
        pb.style.display = 'none';
      }

      const begin = DefaultMetaPage*PagePerMetaPage;
      const end = begin + PagePerMetaPage;
      const PageBtnArray = [...PageBtn];
      const SlicedPageBtn = PageBtnArray.slice(begin, end);

      for(let spb of SlicedPageBtn){
        spb.style.display = '';
      }

      if(DefaultMetaPage == 0){
        LeftArrow.style.display = 'none';
      }
      else{
        LeftArrow.style.display = '';
      }
      // -&gt; 페이지 버튼의 첫 번째 그룹을 표시할 땐 왼쪽 화살표 버튼을 숨긴다.

      // if(DefaultMetaPage == 0){
      //   LeftDoubleArrow.style.display = 'none';
      // }
      // else{
      //   LeftDoubleArrow.style.display = '';
      // }

      if(DefaultMetaPage == MetaPageCount - 1){
        RightArrow.style.display = 'none';
      }
      else{
        RightArrow.style.display = '';
      } 
      // -&gt; 페이지 버튼의 마지막 그룹을 표시할 땐 오른쪽 화살표 버튼을 숨긴다.

      // if(DefaultMetaPage == MetaPageCount - 1){
      //   RightDoubleArrow.style.display = 'none';
      // }
      // else{
      //   RightDoubleArrow.style.display = '';
      // } 
    }

    ShowAndHidePageBtn(0);

    LeftArrow.addEventListener('click', function(event){
      --DefaultMetaPage                      
      // -&gt; 이 기능이 실행될 때마다 이 값이 1씩 떨어진다.
      ShowAndHidePageBtn(DefaultMetaPage);
      ClickPageBtn(DefaultMetaPage*PagePerMetaPage);
    })
    // -&gt; 왼쪽 화살표 버튼을 클릭하면 실행시킬 함수를 설정. 감소한 값이 매개 변수로 사용된다.

    // LeftDoubleArrow.addEventListener('click', function(event){               
    //   let DefaultMetaPage = 0;
    //   ShowAndHidePageBtn(0);
    //   ClickPageBtn(0);
    // })

    RightArrow.addEventListener('click', function(event){
      ++DefaultMetaPage
      // -&gt; 이 기능이 실행될 때마다 이 값이 1씩 증가한다. 증가한 값이 매개 변수로 사용된다.
      ShowAndHidePageBtn(DefaultMetaPage);
      ClickPageBtn(DefaultMetaPage*PagePerMetaPage);
    })
    // -&gt; 오른쪽 화살표 버튼을 클릭하면 실행시킬 함수를 설정.

    // RightDoubleArrow.addEventListener('click', function(event){
    //   let DefaultMetaPage = MetaPageCount - 1;
    //   ShowAndHidePageBtn(MetaPageCount - 1);
    //   ClickPageBtn((MetaPageCount - 1)*PagePerMetaPage);
    // })


&lt;/script&gt;

&lt;/p&gt;
</code>
</pre>
          
          결과:

          <!-- 이미지 -->
          
          야호~ 어거지로 넣긴 했지만 페이지네이션 추가에 성공했다! 페이지를 숫자로만 표시할까 하다가 버튼으로 해줬는데 아주 귀여워서 마음에 든다. 페이지네이션 구현 과정을 설명해야 하는데,, 지금 시간이 부족한 관계로 설명은 다음에 추가하겠다. <br><br>
          
          이번 페이지네이션 사건을 겪으면서 참 많은 걸 배웠다. 페이지네이션 구현 원리를 비롯해 코드를 짜는 사고 방식, 코딩에 능숙한 사람은 변수를 어디에 배치하고 기능은 어떤 순서로 만드는지, 그리고 내가 코드 짜는 방식이 아주 잘못되어 있다는 사실까지.. 뭐 코딩 풋내기인 내게는 매일이 내가 부족하다는 사실 확인의 연속이지만, 이런 식으로 이것저것 고쳐나가려 하다 보면 언젠가는 꽤 능숙해질 수도 있지 않을까 한다.</p>
          
          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ9&gt; 사파리에만 별개의 css 적용하기</h2>
          
          <p>나는 보통 윈도우 환경에서 작업을 한다.  그리고 여차저차 해서 맥북도 하나 가지고 있다. 하여 윈도우에서 만든 걸 맥북에서도 확인하는데, 어째 출력된 결과물이 조금씩 다르다. 아예 다른 건 아닌데 디테일이 조금씩 다르다고 해야 되나. 아마 os의 랜더링 방식에 차이가 있어서 그런 것 같다. 로마에 가면 로마의 법을 따라야 하듯, 맥에 가면 맥의 랜더링 헌법을 따라야 하는 것이다. <br><br>
          
          깊숙이 들어가면 또 굉장한 차이가 있겠지만, 라이트 유저로서 윈도우와 맥 사이의 가장 눈에 띄는 차이점은 폰트 디자인이다. 같은 글꼴을 적용해도 모습이 좀 다르다. 개인적으로는 윈도우 폰트의 느낌이 좋다. 좀 더 날카롭다.. 고 해야 하나. 음.. 거칠다. <br><br>
          
          경험상 윈도우에서의 폰트 디자인은 폰트 원형과는 약간 차이가 있다. 그러니까, 종이에 프린팅해보면 내가 화면으로 봤던 폰트 디자인과는 좀 다른 모습의 폰트가 출력되는 것이다. 과거 저해상도의 모니터에서 가독성을 높이려고 이런 폰트 랜더링을 사용했다고 알고 있는데, 뭐 나는 디자이너도 아닌 관계로 그러거나 말거나.. <br><br>
          
          말이 길어졌는데 내가 하고 싶은 말은, 맥에선 명조나 바탕 같은 삐침이 있는 serif 한글 폰트들이 되게 안 이쁘게 보인다는 것이다! 참고로 고딕처럼 삐침이 없는 폰트는 sans-serif라고 부른다. 언젠가 읽은 적이 있는데 저 sans라는 말이 '없다'라는 뜻이라고 했던 것 같다. 즉, 삐침이 없는 폰트인 것이다. 정확한 정보인지는 확신할 수 없다. <br><br> 
          
          아무튼 나는 글을 주로 책으로 읽었던 세대라 '글은 명조다'라는 편향적 사고를 갖고 살아가고 있고, 하여 이 블로그 콘텐츠의 기본 글씨체도 '예스 명조'로 지정해놨다. 근데!!! 맥에서 보면 세리프체인 명조가 안 예쁘다!!! 온갖 웹폰트들을 적용해봐도 그렇다!!! 그렇다고 그냥 Arial 같은 고딕체로 하자니,, 이거야 품격이 떨어지는 것이다.

          <!-- 이미지 -->

          &lt;맥에서 출력 스샷&gt; </p>
          
          <p>내 블로그가 안 예쁜 글씨체로 보여지는 걸 용납할 수 없었던 나는 두 가지 정도의 방안을 떠올렸다. <br><br>
          
          1. 전 세계의 애플 제품들을 싹 다 파괴한다. <br>
          2. 맥에만 다른 css를 적용하는 방법을 찾는다. <br><br>
          
          1안은 내 MBTI가 I인 관계로 조금 무리가 있었다. 집밖에 나가는 순간부터 배터리가 서서히 떨어지는 인간인 것이다. 세계를 돌며 기기들을 파괴하려 했다가는 나부터 파괴될 가능성이 컸다. <br><br>
          
          그렇다면 남은 건 2안뿐. 검색에 들어갔다. <br><br>
          
          검색어: os별로 다른 css <br><br>
          
          제목: CSS로 특정 브라우저를 선택하는 방법 <br>
          링크: https://blog.pages.kr/2507 <br><br>
          
          이 문서에서는 브라우저&amp;OS별로 다른 css를 적용시켜주는 라이브러리에 대해 소개하고 있었다. 라이브러리 링크를 스크립트 문서에 입력하고 선택하려는 브라우저나 OS의 종류에 따라 명령을 넣어주면 된다고 했다. 나는 이 문제로 아주 짜증이 난 상태인 데다가 원리를 이해하기는 아직 버거워서 냅다 스크립트 문서에 붙여넣었다. <br><br>
          
          코드:
          
<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
&lt;JS&gt;

*/
CSS Browser Selector v0.4.0 (Nov 02, 2010)
Rafael Lima (http://rafael.adm.br)
http://rafael.adm.br/css_browser_selector
License: http://creativecommons.org/licenses/by/2.5/
Contributors: http://rafael.adm.br/css_browser_selector#contributors
*/

function css_browser_selector(u){var ua=u.toLowerCase(),is=function(t){return ua.indexOf(t)&gt;-1},g='gecko',w='webkit',s='safari',o='opera',m='mobile',h=document.documentElement,b=[(!(/opera|webtv/i.test(ua))&amp;&amp;/msie\s(\d)/.test(ua))?('ie ie'+RegExp.$1):is('firefox/2')?g+' ff2':is('firefox/3.5')?g+' ff3 ff3_5':is('firefox/3.6')?g+' ff3 ff3_6':is('firefox/3')?g+' ff3':is('gecko/')?g:is('opera')?o+(/version\/(\d+)/.test(ua)?' '+o+RegExp.$1:(/opera(\s|\/)(\d+)/.test(ua)?' '+o+RegExp.$2:'')):is('konqueror')?'konqueror':is('blackberry')?m+' blackberry':is('android')?m+' android':is('chrome')?w+' chrome':is('iron')?w+' iron':is('applewebkit/')?w+' '+s+(/version\/(\d+)/.test(ua)?' '+s+RegExp.$1:''):is('mozilla/')?g:'',is('j2me')?m+' j2me':is('iphone')?m+' iphone':is('ipod')?m+' ipod':is('ipad')?m+' ipad':is('mac')?'mac':is('darwin')?'mac':is('webtv')?'webtv':is('win')?'win'+(is('windows nt 6.0')?' vista':''):is('freebsd')?'freebsd':(is('x11')||is('linux'))?'linux':'','js']; c = b.join(' '); h.className += ' '+c; return c;}; css_browser_selector(navigator.userAgent);
</code>
</pre>
          
          사용법:

<pre class='pre_codeBlock'>
<code class = 'code_codeBlock'>
예) 맥OS

&lt;CSS&gt;

.mac .ContentSpace{
  padding: 10px 40px;
  font-family: 'menlo', 'Arial';
  font-size: 12px;
  letter-spacing: -0.5px;
  line-height: 140%;
};
</code>
</pre>
                    
          그리고 새로고침을 해보니.. 어.. 이게 되네.. <br><br>
          
          맥OS에서 보여질 CSS를 신나게 적었다. 만들면서 윈도우에 맞추려니까 성에 안 차는 부분들이 있었는데, 이것으로 모두 해결됐다. 폰트 바꾸고 폰트 싸이즈도 바꾸고 블로그 너비도 바꾸고.. 맥은 왠지 내용물이 작아야 귀여워 보이는 것 같다. </p>
          
          <br><hr><br>
          
          <h2>&lt;ㅇ.ㅇ10&gt; 일단 마무리</h2>
          
          <p>지금까지 해서 블로그의 구색을 갖추는 데까지는 어렵사리 성공해냈다. 아직 완전 자동화는 못 시켜서 글을 업로드하려면 수작업으로 진행해야 하는 일들이 있지만, 뭐 이만하면 괜찮은 것 같기도 하다. 마음 같아선 새 글을 등록하는 편집기 기능도 만들어보고 싶었는데,, 아직 내 실력으론 무리인 듯하다. <br><br>
          
          일단 여기서 임시로 마무리하고, 실력을 더 쌓아서 재개발을 진행하러 돌아올 생각이다. 고쳐야 될 부분이 많다. 무엇보다 무자비하게 쓰인 html 문서 안의 function();들을 걷어내야 하고.. 아무튼 다양하다. <br><br>
          
          이렇게 첫 번째 신기루를 실체화해냈다. <br><br>
          
          코드:

          <!-- 코드펜 -->
          
          js 코드가 잘못됐다는데.. 아닌데.. 왤까..</p>
          
          - 끝 -
          </div>
          <!-- 사이드바 -->
        <div class="section_sidebar">
        </div>
      </div>
      <div class="bottom"></div>
    </div>
      <script src="javascript/script.js"></script>
  </body>
</html>
