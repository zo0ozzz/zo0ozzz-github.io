* 2023년 6월 23일 금요일

오늘 부트캠프 수료식이 있었다. 할 일 목록을 교육 기관에 의탁했던 4개월이 지나간 것이다. 이제 다시 혼자가 됐다.

혼자인 게 버거워 부트캠프에 지원했었다. 혼자선 모르겠는 게 너무 많았다. 
이걸 잘하려면 뭘 해야 하는지, 그 과정에서 어디까진 필수고 어디서부턴 굳이인지,
지금 이것저것 해보고 있긴 한데 이게 맞는 길인 건지, 아니라면 어떤 식으로 해나가야 하는지, 등등.
이거야 몹시 혼란했다. 망망대해에서 이런 저런 고민을 하고 있다 보면 쉽게 아득해져버렸다.

교육이 시작됐다. 업체발 할 일 목록의 은총이 내렸다. 처음엔 가랑비였다가 나중엔 장대비로 변했다. 어푸어푸.

일상은 단순해졌다. 하루하루 은총들을 무사히 치워내는 것만이 유일한 목표가 됐다.
머리가 가벼워졌다. 일상을 따로 계획할 필요가 없어진 덕이었다.
나는 흡사 패키지 여행 상품을 구매한 관광객의 마음으로 인솔자가 흔드는 깃발을 따라 발걸음을 옮겨대면 그만이었다.

하지만 그래서 뭐가 꾸역꾸역 술술 풀려갔다는 건 아니고, 이전과는 다른 결로 굉장히 버거워졌다.

부트캠프에 지원할 당시엔 이게 간절했다. 근데 어려웠다. 
뭐 당연하다면 당연했다. 이런 거 배워본 적도 없고. 난 그냥 일개 철학맨이었으니.. 그다음엔 뭐 방송 작가였고..
하루하루 나의 멍청함을 실감했다. 점점 더 멍청이가 되어가는 기분이었다. 괴로웠다.

후반부로 갈수록 간절했던 것이 빌어먹을 것이 됐다. 이 빌어먹을 거 얼른 끝나버렸으면 좋겠단 생각을 자주 했다. 이거야 염치도 없었다.

교육 후반에는 했어야 할 일들을 그냥 넘겨버리는 경우가 많아졌다. 의지박약이기도 했고 뭐 못 따라가기도 했고. 
이제부터 그것들이 부메랑처럼 돌아올 것이다. 그런 식으로 넘겨버린 것들이 보통 그렇듯이.

두 번의 프로젝트 때는 그래도 좀 재밌었다. 냅다 동영상 강의만 볼 때보다 훨씬 나았다.

이윽고 교육 기간이 끝났다. 시원한 기분은 하루가 채 지속되지 못했다.
이제부터 펼쳐질 하루하루를 뭘로 채워나가야 할까. 그 문제에 대한 결정은 온전히 내 몫이 됐다.

나는 다시 혼란해졌다. 고민이 많아졌다. 어쩌면 아무것도 몰랐던 때보다 더 그랬다.

2차 프로젝트 발표회를 마친 지난 주 토요일부터 수료식이 열린 오늘까지, 이런저런 생각을 했다.
개발맨이 되어내기 위해 갖춰야 할 것들을 좀 명확히 해보는 시간이었다.

아무튼 기록을 해야겠는데 마음에 드는 블로그가 없다. 왜 이렇게 안 이쁠까. 첫 번째 할 일이다.

* 건설 계획
: 원래는 하나의 파일이 하나의 게시물을 만드는 아주 정적인 페이지를 만들려고 했다. 데이터베이스가 거의 사용되지 않는. 방명록 정도에나 사용되는. 게시물 내용 수정 같은 것도 브라우저가 아닌 코드 편집기에서 문서 차체를 수정해 최신화하는 식으로. 

왜냐면 문서에는 html 태그도 들어가고 js도 들어가고 할 텐데 그런 내용 자체를 데이터베이스에 저장할 수가 없다고 생각해서.. 그동안의 프로젝트에서도 아이디, 비밀번호 등등, 그러니까 문자열 같은 것만 db에 저장했었다. 데이터가 들어갈 곳에 구멍을 뚫어놓고 사용자의 행동에 맞춰 데이터를 바꿔 꽂아넣는 방식이었다. 그러다 보니 온갖 태그들과 뭐 그런 것들을 담은 코드 뭉치는 db에 저장할 수 없다고 생각했던 것이다.

근데 그러면 굳이 react를 사용할 필요가 없다.

그리고 내 생각이 맞다면 네이버 블로그 같은 건 대체 구현될 수가 있는 건가 싶었다. 하나의 게시물이 생성될 때마다 html, css, js 파일을 만들어지고 그걸 저장해놨다가 요청하면 랜더링한다고..?

뭔가 방법이 있을 거다.

- 구성
: 헤더 + 페이지별 내용 + 푸터. 3단 구성.
	- 헤더 
		- 전역
	- 푸터
		- 전역
	- 페이지별 내용
		- 홈
			- 인삿말
			- 개별 게시물의 제목 리스트
			: 클릭하면 개별 게시글 내용 렌더.
		- 게시물 내용
			- 구성
			: 제목 + 생성일 + 수정일 + 본문 + 관련 게시물 링크
				- html 태그가 포함된 데이터(<p>안녕</p> 같은)는 데이터베이스에 저장해놓고 필요할 때 불러오는 식으로.
  
그냥 깔끔하게 글 제목이 나와 있고 클릭하면 해당하는 컨텐츠가 나왔으면 좋겠다.

* 어떤 스타일링 시스템을 사용할지
- 일단 css는 그럭저럭 생각대로 구현해낼 수 있는 정도.
- 문제는 일관되게 사용할 css 구현 체계를 아직 정립해내지 못했다는 점.
	- 일관된 className 작명이나.. 어떤 상황에서 container를 선언할지.. wrapper와는 어떻게 구별할지 등등.. 
	- 이런 식으로 해보자, 하고 하다 보면 특정한 대응 방식을 적용하기가 애매한 상황을 맞딱뜨리게 된다. 그럴 때면 기존 방식이 별로인 것 같고.. 그 점을 보완해서 다른 방식으로 작명을 하자니 앞선 작업 요소들을 다 바꾸느라 시간이 소요되고.. 아니 다른 프로그래머들은 그냥 쉽게 슉슉 지어나가는 것 같은데 나는 이거 하나 정하기가 왜 이리 어렵나.
	- 상/하위 관계를 나타내려고 상위 요소를 하위 요소의 클래스명에 포함시켜대다 보면 이거야 클래스명이 굉장히 길어져버린다. 그런 클래스명은 요소의 문맥을 반영되어 있어 찬찬히 살펴보면 이해하기 쉽다는 장점이 있지만, 애초에 읽기부터가 싫어져버린다는 게 단점이다.
	- 뭔가를 결정해야 하는 상황에 맞딱뜨릴 때마다 고민을 해야 하다 보니 흐름도 끊기고 시간도 가버린다. 어떤 고민이든 고민이 필요한 상황은 참 귀찮다. 그래서 인간은 당위를 만들어낸 듯하다. 당연한 것. 당연히 어떻게 해야 하는 것. 이게 맞는지 고민할 필요성을 지워버리는것. 예의나 규칙이나 법이나 인권 등. 나는 인간의 역사가 어떤 방향성을 띄게 되어 있는지 정확히는 모르겠지만, 개인적으로는 좀 더 편해지고 싶다, 라는 마음이 큰 영향을 미친다고 생각하고 있다. 나무를 해오고 적당히 패고 아궁이에 넣고 불을 지피고 음식을 데우고 중간중간 오버쿡돼버리진 않았는지 확인하고, 그런 게 영 귀찮아서 전자렌지가 탄생하는 식인 것이다. 예절이나 규칙 법이나 인권 등도 그렇다. 고민은 귀찮고 불편하다. 당연한 것이 정해져 있다면 고민의 필요성은 삭제된다. 편해지는 것이다. 당위는 인간 중 누군가에 의해 만들어지고 배포된다. 어떤 필요성과 그럴 듯한 이유들을 덧붙여져서. 인류 공동 창작인 경우도 있으려나. 특정 집단의 이익을 위해 만들어진 당위도 있을 것이다. 그걸 전면에 내세우거나 하지는 않겠지만. 아니라면 로비스트의 존재가 말이 안 된다. 인간의 필요에 의해 만들어진 당위들. 가만히 생각해보면 무서운 일이다. 대학교 시험에서 이런 문제가 나왔었다. 생명은 소중한가. 소중하다면 왜 소중한가. 아니라면 왜 아닌가. 인간은 평등한가? 인간은 평등해야 하는가?   
- sass, styled-component 중에 하나로 프로젝트를 해보려고 하는데 뭘 선택할지 고민이다. 어떤 도구가 시시때때로 만나는 귀찮은 고민들을 좀 덜어줄 수 있으려나. 역시 써봐야 알겠지. 

(내가 이해하기로는..)

1. sass
: (아마도) 기존 css에 프로그래밍 요소를 더한 스타일링 시스템 라이브러리. 즉, css 확장판.
  - sass 문법으로 스타일링 문서를 작성하면 css로 컴파일링되어 적용됨.
  - css 문법 그대로 사용.
  - 변수 사용 등 각종 프로그래밍적 편의 기능을 제공.
  - 중괄호 문법으로 상/하위 요소 관계를 꺽쇠보다 직관적으로 나타낼 수 있음.
  - 중괄호 문법으로 유효 범위를 생성할 수 있음. 스타일링할 요소의 타겟팅에 편리.
    - 상위 요소의 클래스명을 전체 문맥을 반영할 수 있게 신경 써서 지어주면 그 하위 요소 클래스명 네이밍은 훨씬 간결하게 해줄 수 있을 것 같음. 문맥을 반영할 필요가 없으니까.
			- 예) 
			.home-contentList-container {...}
			.home-contentList-contentList {...}
			.home-contentList-contentList-button {...}
			->
			.home-contentList_container {
        ...
        .contentList {
          ...
          .button {
            ...
          }
        }
			}
    -> 이걸로 클래스명 길어지는 문제는 어느 정도 해결할 수 있을 듯!
  - css 전처리기답게 html이 로드될 때 함께 로드됨. 그로 인한 성능상 이점은 캐싱이 되고.. 음.. 또..
    - 성능 관련한 부분은 차차 알아가보자.. 프로그래머들 엄청 깐깐하던데 널리 쓰이고 있는 시스템이라면 어련히 잘 되어 있겠지..? 무엇보다 아직 내가 성능 신경 쓸 수준이 아님.. 일단 구현부터 잘해내보자. 

2. styled-component
: (아마도) 일단 스타일링만 된 컴포넌트를 생성해내는 방식의 컴포넌트 스타일링 시스템 라이브러리.
  - 이름처럼 스타일링된 html 커스텀 태그(컴포넌트)를 생성.
  - 스타일링이 해당 컴포넌트에만 적용됨. 
    - styled-component 문법으로 생성한 컴포넌트에 고유한 해쉬값으로 구성된 클래스명을 장착해줌. 그 클래스명은 컴포넌트와 해당 컴포넌트에 적용될 스타일을 링크해줌. 자동 생성되는 클래스명에 중복이 없기 때문에 스타일링은 해당 컴포넌트에만 유효하게 됨. 즉, 클래스명 중복 이슈를 신경 쓸 필요가 없게 되는 것. 
    -> 이걸로도 클래스명 길어지는 문제는 어느 정도 해결할 수 있을 듯! 
  - 스타일링과 컴포넌트 생성/사용을 한 문서에서 처리할 수 있어 편리함. 스타일링 파일을 왔다갔다 하지 않아도 됨.
  - 한 문서에 있는 데다 js를 사용하기 때문에 scss보다 스타일링을 프로그래밍적으로 다룰 수 있음.
    - props를 전달받아 스타일링 내용 자체를 변경할 수 있는 등.
      - scss 스타일링 시스템에선 스타일링 내용 자체를 변경할 순 없음. 해당 className에 링크되어 있는 스타일링 문서가 정적이니까. 스타일링을 동적으로 변경하려면 특정 상황에서 요소에 다른 className이 적용될 수 있게 js로 처리해줘야 함. 반면 스타일드컴포넌트 방식에선 props를 이용해 스타일링 내용 자체를 동적으로 변경할 수 있음.
  - js 기반이라는 점에서 장점과 단점이 있을 듯. 아직 세세하게 알진 못함.
    - 런타임에 로드.
      - 음.. 뭔가 있겠지..
    - 이것도 차차 알아가도록 하자..

결론
: 일단 sass로 작업하고 후에 styled-component로 변환해보기로 했다.
- css 기본기를 탄탄하게 다지는 게 우선이라는 생각.
- 스타일링 정석부터 마스터하고 좀 더 특화된 방식을 사용하는 게 좋겠다 싶음. styled-component는 좀 더 프로그래밍적인 기능도 많으니까. 스타일링 상속? 복사?라든가. 뭔가 특화된 방식은 아무래도 기본을 제대로 습득하고 익히는 게 맞는 것 같음.

* 2023년 6월 26일 월요일

<grid>
- fill, fit
  - fill
  : 컨테이너에 한 줄에 빈 너비가 있으면 요소의 개수를 늘려서 빈 너비를 채운다.
  
  - fit
  : 컨테이너 한 줄에 빈 너비가 있으면 기존에 있던 요소의 너비를 늘려서 빈 너비를 채운다.

<이래서 스타일드 컴포넌트 쓰는구나.>
: 스타일링/스크립트 문서 왔다갔다 안 하고 한 문서에서 싹 다 처리할 수 있으면 좋겠단 소망이 싹트네.
: 스타일드 컴포넌트로 스타일링하자.

<스타일드 컴포넌트>
: enhance CSS for styling React component systems.
- 장점
  - 컴포넌트를 추적. 랜더되어야 할 것과 아닌 것 구분. 랜더에 필요한 만큼의 코드만 로드함.
    - 리소스 부담이 줄어들겠죵???
  - 이름 짓기 부담 줄임. 왜? 유일한 클래스네임을 생성하기 때문. 컴포넌트에 1:1로 대응됨.
  - 유지보수에 탁월함. 특정한 컴포넌트에 영향을 주는 스타일을 찾아 여러 파일 간을 이동하지 않아도 됨. 스타일드 컴포넌트와 함께라면 부처님 손바닥 안임.
  
- 참고
  - https://www.zigae.com/styled-components-abstract/
  : 스타일드 컴포넌트의 동작 원리에 대한 글
  
- 사건 사고
  1. 스타일드 컴포넌트 라이브러리 설치가 안 됨.
  : npm install을 아무리 해봐도 안 되는 것임!!!
  - node도 재설치해보고 했는데 안 됨.
  - yarn 설치해서 해결.
  - 근데 yarn으로 설치한 후에 npm으로 다시 설치하니까 또 잘 됨..
  - yarn 제거.

<시멘틱 태그>
: 시멘틱 태그를 잘 써보자. 나는 블로그에 글을 쓰고 싶고 그 형식이 좀 올바르면 좋겠으니까.

- 종류
: 시멘틱 태그는 엄청 많음.
: section, main, article.. 굉장히 헷갈린다. 
  - section
  : 구획.
  : 애매하면 section.
    - 홈 화면에서 각각의 게시물 제목 리스트는 section일까 main일까. 페이지의 중심 컨텐츠니까 main으로 잡았었는데 설명을 읽다 보니 main은 페이지당 하나만 들어가는 게 좋다고 한다. 그래서 section으로 바꿈.
    - 근데 또 main이 맞는 것 같기도 하고.. 이런 식이다. 태그 이름보다는 일관성이 중요하다는데 내 기준이 명확히 서 있지 않아서 항상 갈등하게 된다. 상황상 쓰임과 의미상 쓰임이 일치하지 않으면 골치가 아프다. 이것도 맞는 것 같고 저것도 맞는 것 같고. 골치치.

  - main
  : 가장 주가 되는 요소.
  : section 대신 써도 상관 없을 듯.
    - 페이지당 하나의 main만 존재하는 게 바람직하다고 함.

  - time
  : 시간.

<설계하다 보니까 구현하고 싶은 게 엄청 많은데..>
: 일단 필수 기능만 구현하자. 게시글을 html 태그를 이용해 작성하고 수정하는 기능을 구현하는 게 우선.
- 필수 기능
  1. @전역: 헤더, 푸터
  2. @홈: 게시물 제목 리스트
  3. @게시물 상세: 내용 렌더링 기능, 내용 수정 기능

<설계 변경>
1. 정적 -> 동적
- 처음엔 정적인 블로그를 만들려는 생각이었음. 이전에 html css js로 만들었던 블로그처럼 링크를 클릭하면 해당 게시물을 이루는 파일을 로드해주는.  
  - 링크를 클릭하면 게시글 파일을 로드시켜 보여주는.
  - 서버에서 데이터를 받아올 일이 없음.
- 근데.. 그러면 리액트로 만들 필요가 없다.. 는 생각이 듦.
- 나는 게시물 내용을 html 태그를 사용해서 구성하고 싶음.
- 게시물 내용을 구성하는 코드를 서버에 저장할 수가 있나..? 안 해봐서 모르는 상태임.
- 문자열로 저장할 순 있을 것 같음. 근데 그걸 가져와서 렌더링을 할 수 있을지.. 그리고 몇 가지 방법을 찾았음.
  1. dangerouslySetInnerHTML
    : js의 innerHTML 같은 기능. dom을 직접 조작해 서버에서 받아온 html 내용을 삽입한다.
    - 문제는 react에서 권장되지 않는 방법이라는 거. react는 프로그래머가 가상 dom을 조작하고 그렇게 생성됨 돔을 가지고 react가 진짜 dom과 비교해 dom을 업데이트함. 즉, js처럼 프로그래머가 직접 dom을 조작하면 안 된다는 거.
    - 근데 dangerouslySetInnerHTML는 dom을 직접 조작함.
    - 사용 보류. 다른 방법 먼저 찾아보자.
  
  2. 받아온 html 내용을 컴포넌트에서 그대로 렌더링.
  : 실패. 어떻게 해도 html 내용 자체(태그까지 포함)가 평범한 string처럼 렌더링됨.
    - 리액트가 XSS(Cross-site scripting) 공격을 막기 위해  마련한 방법이라고 함.
      - cross-site scripting 공격
      : 사용자가 악의적으로 입력한 코드가 로드되어 정보를 탈취하거나,, 아무튼 나쁜 일을 일으키는 식으로 공격하는 것.
        - 예를 들면 <img src="..." /> 이런 태그가 웹을 통해 악성 코드를 호출해낼 수 있음. img 태그에는 get 요청 기능이 있으니까.
    - 리액트는 이 공격을 방어하기 위해 태그가 포함된 string 데이터를 문자열 그대로 렌더링함. 그러면 문자열일 뿐인 태그가 작동하지 못하고 XSS 공격도 불가능해질 테니까.
    
  3. 받아온 html 내용을 바로 렌더링하지 않고 태그에 심어서 랜더링하면 어떨까.
  : document.create('div')로 요소를 생성 후 div.innerHTML('서버에서 받아온 데이터')로 html 내용을 탑재한 후에 해당 요소를 컴포넌트에 넘겨 렌더링 하는 것.
    - 소용없다. 역시 문자열로 바뀌어 렌더링됨.
    
- 결론적으로 dangerouslySetInnerHTML 속성을 사용해 게시물 내용 렌더링을 진행하기로 했음.
  - 다른 방법이 없음.. 아니 없는 것 같아 보임..
  - 렌더하는 데이터가 안전한 소스이기만 하면 되지 뭐. 어차피 내가 적은 것만 렌더링할 건데.
  - 사용자의 입력을 받는 곳(댓글, 방명록 등)에는 dangerouslySetInnerHTML 안 써야겠음. 그건 그냥 문자열로.
  
2. 스레드 형태로 만들면 어떨까.
: 게시물 주제에 대해 이전보다 더 발전된 생각이라든가 문제 상황에 대한 해결 아이디어가 시간이 지남에 따라 바뀌는 경우 등, 그런 것들을 순차적으로 기록해두고 한 번에 꺼내볼 수 있었으면 했다.
- 대부분의 블로그, 그러니까 게시판 서비스는 하나의 게시물이 기본적으로 다른 게시물과 독립되어 있음. 단편 소설집에 담긴 각각의 에피소드들처럼.
- 프로그래밍이라는 건 (아마도) 뭔가를 구현하는 데 따르는 문제들을 해결해내는 과정임. 문제 해결을 위한 도구(언어, 라이브러리 등), 해결의 아이디어를 떠올려내는 기반 지식의 정도에 따라 문제 해결 방향이 바뀜. 그리고 그것들은ㅡ가용 도구와 기반 지식ㅡ 시간에 따라 업데이트 됨. 즉, 시간에 따라 문제 해결 방식이 바뀔 수 있음.
- 이런 프로그래밍 공부의 특징엔 레딧, 트위터, 스택오버플로우처럼 스레드 형식의 게시판 구조가 더 적합하지 않을까, 라는 생각이 들었음. 다른 사용자들을 참여시키는 게 아니라 그냥 스레드의 형식만 가져오는 것. 작성은 나 혼자.
- 독립적인 게시물 형식도 이를 구현할 수 있는 방법이 있긴 하지만(같은 주제로 발행된 이전 게시물의 링크를 걸어놓는다거나, 관련 게시물을 토글 버튼 안에 접어놓는다거나) 뭐 그냥 그런 생각이 들었음.
  - 아니면 같은 주제의 게시물 내용을 시간에 따라 계속 수정하는 것도 방법. a few day later.. 이런 걸 구분 요소를 만들어 그때그때 삽입해주기. 게시물들의 기본 정렬 방식은 최근 수정일순으로 하고.
- 그러나! 구현 난이도가 더 높을 것 같음. 지금은 빨리 만들어서 기록에 사용하는 게 중요하니까.. 음..

- 결론) 일단 일반적인 블로그를 만든다. 스레드 형식은 이어질 혁명적 변화 목록에 넣어두고 나중에 여건이 되면 구현한다.

<페이지 분기>
: '/', '/posts/:id'
- react-router-dom의 기능 중 기본 기능 외에는 익숙하지 않음.
  - 일단 간단히 분기만 해놓고 개선할 때 찬찬히 문서를 읽어보자.
  
<db에서 받아온 html 포함 데이터 중 일부 html 태그가 적용되지 않는 문제>
: 대부분의 태그(<div>, <p> 등)들은 잘 적용되어 렌더링되는데 일부 태그(<b> 등)들은 기능하지 않는다.
- 근데 scss 문서에 class 지정해 씹히는 태그의 스타일링을 적용해주면 또 먹힌다.
- 젠장! reset css의 font: inherit; 코드가 <b> 태그의 font-weight: bold; 기능을 막고 있는 거였음!

* 2023년 7월 6일

<data json에서 >